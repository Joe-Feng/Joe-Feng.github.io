<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="TinyHttp源码剖析"><meta name="keywords" content="TinyHttp"><meta name="author" content="Joe_Feng"><meta name="copyright" content="Joe_Feng"><title>TinyHttp源码剖析 | Joe's blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#TinyHttp源码剖析"><span class="toc-number">1.</span> <span class="toc-text">TinyHttp源码剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一、-TinyHttp源码剖析预备知识——HTTP协议"><span class="toc-number">1.1.</span> <span class="toc-text">一、 TinyHttp源码剖析预备知识——HTTP协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-HTTP协议概念"><span class="toc-number">1.2.</span> <span class="toc-text">1. HTTP协议概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-特点"><span class="toc-number">1.3.</span> <span class="toc-text">2. 特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-工作流程"><span class="toc-number">1.4.</span> <span class="toc-text">3. 工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-HTTP报文的结构"><span class="toc-number">1.5.</span> <span class="toc-text">4. HTTP报文的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-请求方法"><span class="toc-number">1.6.</span> <span class="toc-text">5. 请求方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Http与Https的区别"><span class="toc-number">1.7.</span> <span class="toc-text">6. Http与Https的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-如何理解套接字？"><span class="toc-number">1.8.</span> <span class="toc-text">7. 如何理解套接字？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#socket通信流程"><span class="toc-number">2.</span> <span class="toc-text">socket通信流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#二、-Tinyhttp源码剖析"><span class="toc-number">2.1.</span> <span class="toc-text">二、 Tinyhttp源码剖析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-简介"><span class="toc-number">2.2.</span> <span class="toc-text">1. 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-流程分析"><span class="toc-number">2.3.</span> <span class="toc-text">2. 流程分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-每个函数的作用"><span class="toc-number">2.4.</span> <span class="toc-text">3. 每个函数的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-带注释的代码"><span class="toc-number">2.5.</span> <span class="toc-text">4. 带注释的代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三、-思考总结"><span class="toc-number">2.6.</span> <span class="toc-text">三、 思考总结</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g3trl5f8k4j304b04bmx4.jpg"></div><div class="author-info__name text-center">Joe_Feng</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">10</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://pic1.win4000.com/wallpaper/8/565d5415d62dd.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Joe's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">个人主页</a><a class="site-page" href="/archives">文章总览</a><a class="site-page" href="/categories/项目实战">项目实战</a><a class="site-page" href="/categories/读书/">读书笔记</a><a class="site-page" href="/categories/生活杂谈">生活杂谈</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">TinyHttp源码剖析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-20</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/项目实战/">项目实战</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">11.9k</span><span class="post-meta__separator">|</span><span>阅读时长: 43 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h3 id="TinyHttp源码剖析"><a href="#TinyHttp源码剖析" class="headerlink" title="TinyHttp源码剖析"></a>TinyHttp源码剖析</h3><h4 id="一、-TinyHttp源码剖析预备知识——HTTP协议"><a href="#一、-TinyHttp源码剖析预备知识——HTTP协议" class="headerlink" title="一、 TinyHttp源码剖析预备知识——HTTP协议"></a>一、 TinyHttp源码剖析预备知识——HTTP协议</h4><h4 id="1-HTTP协议概念"><a href="#1-HTTP协议概念" class="headerlink" title="1. HTTP协议概念"></a>1. HTTP协议概念</h4><p>HTTP协议，即超文本传输协议(Hypertext transfer protocol)。是一种详细规定了浏览器和万维网(WWW = World Wide Web)服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。</p>
<p>HTTP协议是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。</p>
<p>HTTP是一个<strong>应用层协议</strong>，由请求和响应构成，是一个<strong>标准的客户端服务器模型</strong>。HTTP是一个<strong>无状态的协议。</strong></p>
<p>在Internet中所有的传输都是通过TCP/IP进行的。HTTP协议作为TCP/IP模型中应用层的协议也不例外。HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。</p>
<p><strong>HTTP默认的端口号为80，HTTPS的端口号为443。</strong></p>
<p><strong>浏览网页是HTTP的主要应用，但是这并不代表HTTP就只能应用于网页的浏览。</strong>HTTP是一种协议，只要通信的双方都遵守这个协议，HTTP就能有用武之地。比如咱们常用的QQ，迅雷这些软件，都会使用HTTP协议(还包括其他的协议)。</p>
<h4 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h4><ol>
<li><p><strong>HTTP 0.9和1.0使用非持续连接</strong>：限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。<strong>HTTP 1.1使用持续连接</strong>：不必为每个web对象创建一个新的连接，一个连接可以传送多个对象，采用这种方式可以节省传输时间。</p>
</li>
<li><p><strong>无状态</strong>：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。</p>
 <a id="more"></a>

<hr>
<p>协议的状态是指下一次传输可以“记住”这次传输信息的能力。</p>
<p>http是不会为了下一次连接而维护这次连接所传输的信息,为了保证服务器内存。</p>
<p>比如客户获得一张网页之后关闭浏览器，然后再一次启动浏览器，再登陆该网站，但是服务器并不知道客户关闭了一次浏览器。</p>
<p>由于Web服务器要面对很多浏览器的并发访问，为了提高Web服务器对并发访问的处理能力，在设计HTTP协议时规定Web服务器发送HTTP应答报文和文档时，不保存发出请求的Web浏览器进程的任何状态信息。这有可能出现一个浏览器在短短几秒之内两次访问同一对象时，服务器进程不会因为已经给它发过应答报文而不接受第二期服务请求。由于Web服务器不保存发送请求的Web浏览器进程的任何信息，因此HTTP协议属于无状态协议（Stateless Protocol）。</p>
<hr>
<p><strong>HTTP协议是无状态的和Connection: keep-alive的区别：</strong></p>
<p>无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。</p>
<p>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。</p>
<p>从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。</p>
<p>Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。</p>
</li>
</ol>
<h4 id="3-工作流程"><a href="#3-工作流程" class="headerlink" title="3. 工作流程"></a>3. 工作流程</h4><p>1）首先客户机与服务器需要建立连接（TCP连接-三次握手）。只要单击某个超级链接，HTTP的工作开始。</p>
<p>2）建立连接后，客户机发送一个请求给服务器，<strong>请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。</strong></p>
<p>例如：GET / HTTP/1.1\r\nHost: <a href="http://www.sina.com.cn\r\nConnection" target="_blank" rel="noopener">www.sina.com.cn\r\nConnection</a>: close\r\n\r\n</p>
<p>3）服务器接到请求后，给予相应的<strong>响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</strong></p>
<p>4）客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。</p>
<p>如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。</p>
<h4 id="4-HTTP报文的结构"><a href="#4-HTTP报文的结构" class="headerlink" title="4. HTTP报文的结构"></a>4. HTTP报文的结构</h4><p>HTTP报文分为两类：请求报文（从客户向服务器发送），响应报文（从服务器到客户的应答）</p>
<p>请求报文和响应报文都是由三部分组成的：开始行、首部行、实体主体</p>
<p>请求报文和响应报文的区别在于开始行的不同，请求报文的开始行叫请求行，响应报文的开始行叫状态行</p>
<p><img src="https://images2018.cnblogs.com/blog/1250974/201802/1250974-20180223120728672-2127185812.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HTTP之状态码</span><br><span class="line">状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</span><br><span class="line">1xx：指示信息--表示请求已接收，继续处理</span><br><span class="line">2xx：成功--表示请求已被成功接收、理解、接受</span><br><span class="line">3xx：重定向--要完成请求必须进行更进一步的操作</span><br><span class="line">4xx：客户端错误--请求有语法错误或请求无法实现</span><br><span class="line">5xx：服务器端错误--服务器未能实现合法的请求</span><br><span class="line"></span><br><span class="line">常见状态码：</span><br><span class="line">200 OK //客户端请求成功</span><br><span class="line">400 Bad Request //客户端请求有语法错误，不能被服务器所理解</span><br><span class="line">401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</span><br><span class="line">403 Forbidden //服务器收到请求，但是拒绝提供服务</span><br><span class="line">404 Not Found //请求资源不存在，eg：输入了错误的URL</span><br><span class="line">500 Internal Server Error //服务器发生不可预期的错误</span><br><span class="line">503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</span><br></pre></td></tr></table></figure>

<h4 id="5-请求方法"><a href="#5-请求方法" class="headerlink" title="5. 请求方法"></a>5. 请求方法</h4><p>请求方法用来标明客户端希望服务器对资源执行的动作。</p>
<p><strong>HTTP服务器至少应该实现GET和HEAD方法</strong>，其他方法都是可选的     </p>
<p><strong>方法名称是区分大小写的</strong>。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed）；当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。</p>
<p><strong>GET</strong>：向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在web app.中。其中一个原因是GET可能会被网络蜘蛛等随意访问。    </p>
<p><strong>HEAD</strong> ：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。</p>
<p><strong>POST</strong> ：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。    </p>
<p>PUT ：将请求的主体部分存储在服务器中，如上传文件     </p>
<p>DELETE ：请求删除服务器上指定的文档     </p>
<p>TRACE ：追踪请求到达服务器中间经过的代理服务器     </p>
<p>OPTIONS ：请求服务器返回对指定资源支持使用的请求方法</p>
<hr>
<p><strong>GET和POST的区别</strong>：</p>
<p><strong>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</strong></p>
<p><strong>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）</strong></p>
<p>1、GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. </p>
<p>POST方法是把提交的数据放在HTTP包的Body中。</p>
<p>2、GET提交的数据大小有限制，最多只能有1024字节（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制。</p>
<p>3、GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</p>
<p>4、GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。</p>
<h4 id="6-Http与Https的区别"><a href="#6-Http与Https的区别" class="headerlink" title="6. Http与Https的区别"></a>6. Http与Https的区别</h4><p>1）HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS加密后的，HTTPS具有更高的安全性</p>
<p>2）HTTPS在TCP三次握手阶段之后，还需要进行SSL 的handshake，协商加密使用的对称加密密钥</p>
<p>3）HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书</p>
<p>4）HTTP协议端口是80，HTTPS协议端口是443</p>
<p><strong>HTTPS优点：</strong></p>
<p>HTTPS传输数据过程中使用密钥进行加密，所以安全性更高</p>
<p>HTTPS协议可以认证用户和服务器，确保数据发送到正确的用户和服务器</p>
<p><strong>HTTPS缺点：</strong></p>
<p>HTTPS握手阶段延时较高：由于在进行HTTP会话之前还需要进行SSL握手，因此HTTPS协议握手阶段延时增加</p>
<p>HTTPS部署成本高：一方面HTTPS协议需要使用证书来验证自身的安全性，所以需要购买CA证书；另一方面由于采用HTTPS协议需要进行加解密的计算，占用CPU资源较多，需要的服务器配置或数目高</p>
<h4 id="7-如何理解套接字？"><a href="#7-如何理解套接字？" class="headerlink" title="7. 如何理解套接字？"></a>7. 如何理解套接字？</h4><p><a href="https://baike.baidu.com/item/传输层/4329536" target="_blank" rel="noopener">传输层</a>实现<a href="https://baike.baidu.com/item/端到端/8851783" target="_blank" rel="noopener">端到端</a>的通信，因此，每一个传输层连接有两个端点。那么，传输层连接的端点是什么呢？不是<a href="https://baike.baidu.com/item/主机/455151" target="_blank" rel="noopener">主机</a>，不是主机的<a href="https://baike.baidu.com/item/IP地址/150859" target="_blank" rel="noopener">IP地址</a>，不是应用进程，也不是传输层的协议端口。传输层连接的端点叫做套接字（socket）。根据RFC793的定义：<a href="https://baike.baidu.com/item/端口号/10883658" target="_blank" rel="noopener">端口号</a>拼接到IP地址就构成了套接字。所谓套接字，实际上是一个通信端点，每个套接字都有一个套接字序号，包括主机的IP地址与一个16位的主机端口号，即形如（主机IP地址：端口号）。例如，如果IP地址是210.37.145.1，而端口号是23，那么得到套接字就是（210.37.145.1：23）。</p>
<p>总之，<strong>套接字Socket=（IP地址：端口号）</strong>，套接字的表示方法是点分十进制的IP地址后面写上端口号，中间用冒号或逗号隔开。每一个传输层连接唯一地被通信两端的两个端点（即两个套接字）所确定。</p>
<p>套接字可以看成是两个网络应用程序进行通信时，各自通信连接中的一个端点。通信时，其中的一个网络应用程序将要传输的一段信息写入它所在主机的Socket中，该Socket通过网络接口卡的传输介质将这段信息发送给另一台主机的Socket中，使这段信息能传送到其他程序中。因此，两个应用程序之间的数据传输要通过套接字来完成。</p>
<p>在网络应用程序设计时，由于TCP/IP的核心内容被封装在操作系统中，如果应用程序要使用TCP/IP，可以通过系统提供的TCP/IP的编程接口来实现。在Windows环境下，网络应用程序编程接口称作Windows Socket。为了支持用户开发面向应用的通信程序，大部分系统都提供了一组基于TCP或者UDP的应用程序编程接口（API），该接口通常以一组函数的形式出现，也称为套接字（Socket）。</p>
<hr>
<p>能够唯一标示网络中的进程后，它们就可以利用socket进行通信了，什么是socket呢？我们经常把socket翻译为套接字<strong>，socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。</strong></p>
<p><a href="https://s1.ax1x.com/2020/04/16/JAKKYR.jpg" target="_blank" rel="noopener">https://s1.ax1x.com/2020/04/16/JAKKYR.jpg</a></p>
<p>socket起源于UNIX，在Unix一切皆文件哲学的思想下，socket是一种”打开—读/写—关闭”模式的实现，服务器和客户端各自维护一个”文件”，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。</p>
<h3 id="socket通信流程"><a href="#socket通信流程" class="headerlink" title="socket通信流程"></a>socket通信流程</h3><p>socket是”打开—读/写—关闭”模式的实现，以使用TCP协议通讯的socket为例，其交互流程大概是这样子的</p>
<p><img src="https://images0.cnblogs.com/blog/349217/201312/05232335-fb19fc7527e944d4845ef40831da4ec2.png" alt="img"></p>
<ol>
<li><p><em>服务器根据地址类型（ipv4,ipv6）、socket类型、协议创建socket</em>   </p>
<p><em>int socket(int domain, int type, int protocol);</em></p>
</li>
<li><p><em>服务器为socket绑定ip地址和端口号</em></p>
</li>
<li><p><em>服务器socket监听端口号请求，随时准备接收客户端发来的连接，这时候服务器的socket并没有被打开</em></p>
</li>
<li><p>客户端创建socket</p>
</li>
<li><p>客户端打开socket，根据服务器ip地址和端口号试图连接服务器socket</p>
</li>
<li><p><em>服务器socket接收到客户端socket请求，被动打开，开始接收客户端请求，直到客户端返回连接信息。这时候socket进入<strong>阻塞</strong>状态，所谓阻塞即accept()方法一直到客户端返回连接信息后才返回，开始接收下一个客户端谅解请求</em></p>
</li>
<li><p>客户端连接成功，向服务器发送连接状态信息</p>
</li>
<li><p><em>服务器accept方法返回，连接成功</em></p>
</li>
<li><p>客户端向socket写入信息</p>
</li>
<li><p><em>服务器读取信息</em></p>
</li>
<li><p>客户端关闭</p>
</li>
<li><p><em>服务器端关闭</em></p>
</li>
</ol>
<p>服务器socket与客户端socket建立连接的部分其实就是大名鼎鼎的三次握手</p>
<p><img src="https://images0.cnblogs.com/blog/349217/201312/05234946-b80841921eae4d2ab983f26ed9023768.png" alt="img"></p>
<hr>
<p> <strong>socket编程API</strong></p>
<p>前面提到socket是”打开—读/写—关闭”模式的实现，简单了解一下socket提供了哪些API供应用程序使用，还是以TCP协议为例，看看Unix下的socket API，其它语言都很类似（PHP甚至名字都几乎一样），这里我就简单解释一下方法作用和参数，具体使用有兴趣同学可以看看博客参考中的链接或者上网搜索</p>
<ul>
<li><strong>socket()：创建套接字。</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int socket(int domain, int type, int protocol);</span><br></pre></td></tr></table></figure>

<p>根据指定的地址族、数据类型和协议来分配一个socket的描述字及其所用的资源。</p>
<p>domain:协议族，常用的有AF_INET、AF_INET6、AF_LOCAL、AF_ROUTE其中AF_INET代表使用ipv4地址</p>
<p>type:socket类型，常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等</p>
<p>protocol:协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等</p>
<ul>
<li><strong>bind()：指定本地地址。</strong>一个套接字用socket()创建后，它其实还没有与任何特定的本地或目的地址相关联。在很多情况下，应用程序并不关心它们使用的本地地址，这时就可以不用调用bind指定本地的地址，而由协议软件为它们选择一个。但是，在某个知名端口（Well-known Port）上操作的服务器进程必须要对系统指定本地端口。所以一旦创建了一个套接字，服务器就必须使用bind()系统调用为套接字建立一个本地地址。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure>

<p>把一个地址族中的特定地址赋给socket</p>
<p>sockfd:socket描述字，也就是socket引用</p>
<p>addr:要绑定给sockfd的协议地址</p>
<p>addrlen:地址的长度</p>
<p><em>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。</em></p>
<ul>
<li><strong>listen()：设置等待连接状态。</strong>对于一个服务器的程序，当申请到套接字，并调用bind()与本地地址绑定后，就应该等待某个客户机的程序来要求连接。listen()就是把一个套接字设置为这种状态的函数。<strong>同时也可以设置允许的最大连接数</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int listen(int sockfd, int backlog);</span><br></pre></td></tr></table></figure>

<p>监听socket</p>
<p>sockfd:要监听的socket描述字</p>
<p>backlog:相应socket可以排队的最大连接个数 </p>
<ul>
<li><strong>connect()：将套接字连接到目的地址。</strong>初始创建的套接字并未与任何外地目的地址关联。客户机可以调用connect()为套接字绑定一个永久的目的地址，将它置于已连接状态。对数据流方式的套接字，必须在传输数据前，调用connect()构造一个与目的地的TCP连接，并在不能构造连接时返回一个差错代码。如果是数据报方式，则不是必须在传输数据前调用connect。如果调用了connect()，也并不像数据流方式那样发送请求建连的报文，而是只在本地存储目的地址，以后该socket上发送的所有数据都送往这个地址，程序员就可以免去为每一次发送数据都指定目的地址的麻烦。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure>

<p>连接某个socket</p>
<p>sockfd:客户端的socket描述字</p>
<p>addr:服务器的socket地址</p>
<p>addrlen:socket地址的长度</p>
<ul>
<li><strong>accept()：接受连接请求。</strong>服务器进程使用系统调用socket，bind和listen创建一个套接字，将它绑定到知名的端口，并指定连接请求的队列长度。然后，服务器调用accept进入等待状态，直到到达一个连接请求。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span><br></pre></td></tr></table></figure>

<p> TCP服务器监听到客户端请求之后，调用accept()函数取接收请求</p>
<p>sockfd:服务器的socket描述字</p>
<p>addr:客户端的socket地址</p>
<p>addrlen:socket地址的长度</p>
<ul>
<li><strong>send()/recv()或write（）/read()：发送和接收数据 。</strong>在数据流方式中，一个连接建立以后，或者在数据报方式下，调用了connect()进行了套接字与目的地址的绑定后，就可以调用send()和reev()函数进行数据传输。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t read(int fd, void *buf, size_t count);</span><br></pre></td></tr></table></figure>

<p>读取socket内容</p>
<p>fd:socket描述字</p>
<p>buf：缓冲区</p>
<p>count：缓冲区长度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t write(int fd, const void *buf, size_t count);</span><br></pre></td></tr></table></figure>

<p>向socket写入内容，其实就是发送内容</p>
<p>fd:socket描述字</p>
<p>buf：缓冲区</p>
<p>count：缓冲区长度</p>
<ul>
<li><strong>close()：关闭套接字。</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int close(int fd);</span><br></pre></td></tr></table></figure>

<p>socket标记为以关闭 ，使相应socket描述字的引用计数-1，当引用计数为0的时候，触发TCP客户端向服务器发送终止连接请求。</p>
<h4 id="二、-Tinyhttp源码剖析"><a href="#二、-Tinyhttp源码剖析" class="headerlink" title="二、 Tinyhttp源码剖析"></a>二、 Tinyhttp源码剖析</h4><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h4><p>tinyhttpd是使用c语言开发的超轻量级http服务器，通过代码流程可以了解http服务器的基本处理流程，并且涉及了网络套接字，线程，父子进程，管道等等知识点；</p>
<h4 id="2-流程分析"><a href="#2-流程分析" class="headerlink" title="2. 流程分析"></a>2. 流程分析</h4><p>(1) 服务器启动，等待客户端请求到来；</p>
<p>(2) 客户端请求到来，创建新线程处理该请求；</p>
<p>(3) 读取httpHeader中的method，截取url，其中GET方法需要记录url问号之后的参数串;</p>
<p>(4) 根据url构造完整路径，如果是/结尾，则指定为该目录下的index.html;</p>
<p>(5) 获取文件信息，如果找不到文件，返回404，找到文件则判断文件权限；</p>
<p>(6) 如果是GET请求并且没有参数，或者文件不可执行，则直接将文件内容构造http信息返回给客户端；</p>
<p>(7) 如果是GET带参数，POST，文件可执行，则执行CGI；</p>
<p>(8) GET请求略过httpHeader，POST方法需要记录httpHeader中的Content-Length:xx；</p>
<p>(9) 创建管道用于父子进程通信，fork产生子进程；</p>
<p>(10) 子进程设置环境变量，将标准输入和输出与管道相连，并且通过exec执行CGI；</p>
<p>(11) 如果是POST，父进程将读到post内容发送给子进程，并且接收子进程的输出，输出给客户端；</p>
<p><img src="http://www.wfuyu.com/upload/caiji/20160601/C4zOrI9.jpg" alt="img"></p>
<h4 id="3-每个函数的作用"><a href="#3-每个函数的作用" class="headerlink" title="3. 每个函数的作用"></a>3. 每个函数的作用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// accept_request:  处理从套接字上监听到的一个 HTTP 请求，在这里可以很大一部分地体现服务器处理请求流程。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept_request</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="comment">// bad_request: 返回给客户端这是个错误请求，HTTP 状态吗 400 BAD REQUEST.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bad_request</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// cat: 读取服务器上某个文件写到 socket 套接字。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cat</span><span class="params">(<span class="keyword">int</span>, FILE *)</span></span>;</span><br><span class="line"><span class="comment">//  cannot_execute: 主要处理发生在执行 cgi 程序时出现的错误。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cannot_execute</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// error_die: 把错误信息写到 perror 并退出。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="comment">// execute_cgi: 运行 cgi 程序的处理，也是个主要函数。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute_cgi</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="comment">// get_line: 读取套接字的一行，把回车换行等情况都统一为换行符结束</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_line</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// headers: 把 HTTP 响应的头部写到套接字</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">headers</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="comment">// not_found: 主要处理找不到请求的文件时的情况。 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">not_found</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// sever_file: 调用 cat 把服务器文件返回给浏览器。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_file</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="comment">//  startup: 初始化 httpd 服务，包括建立套接字，绑定端口，进行监听等。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">startup</span><span class="params">(u_short *)</span></span>;</span><br><span class="line"><span class="comment">//unimplemented: 返回给浏览器表明收到的 HTTP 请求所用的 method 不被支持。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unimplemented</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>建议源码阅读顺序： main -&gt; startup -&gt; accept_request -&gt; execute_cgi, 通晓主要工作流程后再仔细把每个函数的源码看一看。</p>
<h4 id="4-带注释的代码"><a href="#4-带注释的代码" class="headerlink" title="4. 带注释的代码"></a>4. 带注释的代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISspace(x) isspace((int)(x))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_STRING <span class="meta-string">"Server: jdbhttpd/0.1.0\r\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STDIN   0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STDOUT  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STDERR  2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// accept_request:  处理从套接字上监听到的一个 HTTP 请求，在这里可以很大一部分地体现服务器处理请求流程。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept_request</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="comment">// bad_request: 返回给客户端这是个错误请求，HTTP 状态吗 400 BAD REQUEST.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bad_request</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// cat: 读取服务器上某个文件写到 socket 套接字。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cat</span><span class="params">(<span class="keyword">int</span>, FILE *)</span></span>;</span><br><span class="line"><span class="comment">//  cannot_execute: 主要处理发生在执行 cgi 程序时出现的错误。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cannot_execute</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// error_die: 把错误信息写到 perror 并退出。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="comment">// execute_cgi: 运行 cgi 程序的处理，也是个主要函数。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute_cgi</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="comment">// get_line: 读取套接字的一行，把回车换行等情况都统一为换行符结束</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_line</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// headers: 把 HTTP 响应的头部写到套接字</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">headers</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="comment">// not_found: 主要处理找不到请求的文件时的情况。 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">not_found</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// sever_file: 调用 cat 把服务器文件返回给浏览器。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_file</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="comment">//  startup: 初始化 httpd 服务，包括建立套接字，绑定端口，进行监听等。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">startup</span><span class="params">(u_short *)</span></span>;</span><br><span class="line"><span class="comment">//unimplemented: 返回给浏览器表明收到的 HTTP 请求所用的 method 不被支持。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unimplemented</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* 对于每一个http请求，都会创建一个线程，线程去执行这个函数去处理请求</span></span><br><span class="line"><span class="comment"> * 参数: 连接到客户端的套接字*/</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept_request</span><span class="params">(<span class="keyword">int</span> client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">char</span> buf[<span class="number">1024</span>];    <span class="comment">// 读取行数据时的缓冲区</span></span><br><span class="line"> <span class="keyword">int</span> numchars;      <span class="comment">// 读取了多少字符</span></span><br><span class="line"> <span class="keyword">char</span> method[<span class="number">255</span>];  <span class="comment">// 存储HTTP请求方法名称（字符串）</span></span><br><span class="line"> <span class="keyword">char</span> url[<span class="number">255</span>];     <span class="comment">// 存储url</span></span><br><span class="line"> <span class="keyword">char</span> path[<span class="number">512</span>];</span><br><span class="line"> <span class="keyword">size_t</span> i, j;   <span class="comment">//size_t在cstddef头文件中，和int应该具有相同的长度</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"> <span class="keyword">int</span> cgi = <span class="number">0</span>;      <span class="comment">/* becomes true if server decides this is a CGI</span></span><br><span class="line"><span class="comment">                    * program */</span></span><br><span class="line"> <span class="keyword">char</span> *query_string = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读http 请求的第一行数据（request line），把请求方法存进 method 中</span></span><br><span class="line"><span class="comment">// 一个HTTP请求报文由请求行（requestline）、请求头部（header）、空行和请求数据4个部分组成</span></span><br><span class="line"><span class="comment">// 请求行由请求方法字段（get或post）、URL字段和HTTP协议版本字段3个字段组成</span></span><br><span class="line"><span class="comment">// 它们用空格分隔。如：GET /index.html HTTP/1.1。</span></span><br><span class="line"><span class="comment">// 解析请求行，把方法字段保存在method变量中。</span></span><br><span class="line"><span class="comment">// 读取HTTP头第一行：GET/index.php HTTP 1.1</span></span><br><span class="line"> numchars = get_line(client, buf, <span class="keyword">sizeof</span>(buf)); <span class="comment">//get_line函数：读取套接字的一行，把回车换行等情况都统一为换行符结束。</span></span><br><span class="line"> i = <span class="number">0</span>; j = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="comment">// 把客户端的请求方法存到method数组</span></span><br><span class="line"> <span class="keyword">while</span> (!ISspace(buf[j]) &amp;&amp; (i &lt; <span class="keyword">sizeof</span>(method) - <span class="number">1</span>))</span><br><span class="line"> &#123;</span><br><span class="line">  method[i] = buf[j];</span><br><span class="line">  i++; j++;</span><br><span class="line"> &#125;</span><br><span class="line"> method[i] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">//如果请求的方法不是 GET 或 POST 任意一个的话就直接发送 response 告诉客户端没实现该方法</span></span><br><span class="line"> <span class="comment">/*头文件：#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">定义函数：int strcasecmp (const char *s1, const char *s2);</span></span><br><span class="line"><span class="comment">函数说明：strcasecmp()用来比较参数s1 和s2 字符串，比较时会自动忽略大小写的差异。</span></span><br><span class="line"><span class="comment">返回值：若参数s1 和s2 字符串相同则返回0。s1 长度大于s2 长度则返回大于0 的值，s1 长度若小于s2 长度则返回小于0 的值。*/</span></span><br><span class="line"> <span class="keyword">if</span> (strcasecmp(method, <span class="string">"GET"</span>) &amp;&amp; strcasecmp(method, <span class="string">"POST"</span>))</span><br><span class="line"> &#123;</span><br><span class="line">  unimplemented(client); <span class="comment">//unimplemented函数：返回给浏览器表明收到的HTTP请求所用的method不被支持。</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">//如果是 POST 方法就将 cgi 标志变量置一(true)</span></span><br><span class="line"> <span class="keyword">if</span> (strcasecmp(method, <span class="string">"POST"</span>) == <span class="number">0</span>)</span><br><span class="line">  cgi = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析并保存请求的URL（如有问号，也包括问号及之后的内容）</span></span><br><span class="line"> i = <span class="number">0</span>;</span><br><span class="line"> <span class="comment">//跳过所有的空白字符(空格)</span></span><br><span class="line"> <span class="keyword">while</span> (ISspace(buf[j]) &amp;&amp; (j &lt; <span class="keyword">sizeof</span>(buf))) </span><br><span class="line">  j++;</span><br><span class="line"> <span class="comment">//然后从缓冲区把 URL 读出来放到 url 数组中</span></span><br><span class="line"> <span class="keyword">while</span> (!ISspace(buf[j]) &amp;&amp; (i &lt; <span class="keyword">sizeof</span>(url) - <span class="number">1</span>) &amp;&amp; (j &lt; <span class="keyword">sizeof</span>(buf)))</span><br><span class="line"> &#123;</span><br><span class="line">  url[i] = buf[j];</span><br><span class="line">  i++; j++;</span><br><span class="line"> &#125;</span><br><span class="line"> url[i] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果这个请求是一个 GET 方法的话</span></span><br><span class="line"><span class="comment">// 如果是get方法，请求参数和对应的值附加在URL后面，利用一个问号（“？”）代表URL的结</span></span><br><span class="line"><span class="comment">// 尾与请求参数的开始，传递参数长度受限制。如index.jsp?10023，其中10023就是要传递</span></span><br><span class="line"><span class="comment">// 的参数。这段代码将参数保存在query_string中。</span></span><br><span class="line"> <span class="keyword">if</span> (strcasecmp(method, <span class="string">"GET"</span>) == <span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="comment">//用一个指针指向 url</span></span><br><span class="line">  query_string = url;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//去遍历这个 url，跳过字符 ？前面的所有字符，如果遍历完毕也没找到字符 ？则退出循环</span></span><br><span class="line">  <span class="keyword">while</span> ((*query_string != <span class="string">'?'</span>) &amp;&amp; (*query_string != <span class="string">'\0'</span>))</span><br><span class="line">   query_string++;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//退出循环后检查当前的字符是 ？还是字符串(url)的结尾</span></span><br><span class="line">  <span class="keyword">if</span> (*query_string == <span class="string">'?'</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="comment">//如果是 ？ 的话，证明这个请求需要调用 cgi，将 cgi 标志变量置一(true)</span></span><br><span class="line">   cgi = <span class="number">1</span>;</span><br><span class="line">   <span class="comment">//从字符 ？ 处把字符串 url 给分隔会两份</span></span><br><span class="line">   *query_string = <span class="string">'\0'</span>;</span><br><span class="line">   <span class="comment">//使指针指向字符 ？后面的那个字符</span></span><br><span class="line">   query_string++;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存有效的url地址并加上请求地址的主页索引。默认的根目录是htdocs下</span></span><br><span class="line"><span class="comment">// 这里是做以下路径拼接，因为url字符串以'/'开头，所以不用拼接新的分割符</span></span><br><span class="line"><span class="comment">// 格式化url到path数组，html文件都在htdocs中</span></span><br><span class="line"><span class="comment">//将前面分隔两份的前面那份字符串，拼接在字符串htdocs的后面之后就输出存储到数组 path 中。相当于现在 path 中存储着一个字符串</span></span><br><span class="line"> <span class="built_in">sprintf</span>(path, <span class="string">"htdocs%s"</span>, url);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//如果 path 数组中的这个字符串的最后一个字符是以字符 / 结尾的话，就拼接上一个"index.html"的字符串。即默认访问index.html</span></span><br><span class="line"> <span class="keyword">if</span> (path[<span class="built_in">strlen</span>(path) - <span class="number">1</span>] == <span class="string">'/'</span>)</span><br><span class="line">  <span class="built_in">strcat</span>(path, <span class="string">"index.html"</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 访问请求的文件，如果文件不存在直接返回，如果存在就调用CGI程序来处理</span></span><br><span class="line"> <span class="comment">/*头文件:    #include &lt;sys/stat.h&gt; </span></span><br><span class="line"><span class="comment">函数定义:    int stat(const char *file_name, struct stat *buf); </span></span><br><span class="line"><span class="comment">函数说明:    通过文件名filename获取文件信息，并保存在buf所指的结构体stat中 </span></span><br><span class="line"><span class="comment">返回值:     执行成功则返回0，失败返回-1，错误代码存于errno（需要include &lt;errno.h&gt;）*/</span></span><br><span class="line"> <span class="keyword">if</span> (stat(path, &amp;st) == <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="comment">//如果不存在，那把这次 http 的请求后续的内容(head 和 body)全部读完并忽略</span></span><br><span class="line">  <span class="keyword">while</span> ((numchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">"\n"</span>, buf))  <span class="comment">/* read &amp; discard headers */</span></span><br><span class="line">   numchars = get_line(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">  <span class="comment">//然后返回一个找不到文件的 response 给客户端</span></span><br><span class="line">  not_found(client);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;<span class="comment">// 如果文件存在但却是个目录，则继续拼接路径，默认访问这个目录下的index.html</span></span><br><span class="line">  <span class="comment">//文件存在，那去跟常量S_IFMT相与，相与之后的值可以用来判断该文件是什么类型的</span></span><br><span class="line">  <span class="comment">//S_IFMT参读《TLPI》P281，与下面的三个常量一样是包含在&lt;sys/stat.h&gt;</span></span><br><span class="line">  <span class="keyword">if</span> ((st.st_mode &amp; S_IFMT) == S_IFDIR)  </span><br><span class="line">   <span class="comment">//如果这个文件是个目录，那就需要再在 path 后面拼接一个"/index.html"的字符串</span></span><br><span class="line">   <span class="built_in">strcat</span>(path, <span class="string">"/index.html"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//如果这个文件是一个可执行文件，不论是属于用户/组/其他这三者类型的，就将 cgi 标志变量置一</span></span><br><span class="line">   <span class="comment">//在调用CGI之前有一段是对用户权限的判断，对应含义如下</span></span><br><span class="line">   <span class="comment">//S_IXUSR：用户可以执行</span></span><br><span class="line">   <span class="comment">//S_IXGRP：组可以执行</span></span><br><span class="line">   <span class="comment">//S_IXOTH：其它人可以执行</span></span><br><span class="line">  <span class="keyword">if</span> ((st.st_mode &amp; S_IXUSR) ||       </span><br><span class="line">      (st.st_mode &amp; S_IXGRP) ||</span><br><span class="line">      (st.st_mode &amp; S_IXOTH)    )</span><br><span class="line">    cgi = <span class="number">1</span>;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">if</span> (!cgi)</span><br><span class="line">   <span class="comment">//如果不需要 cgi 机制的话，直接把服务器文件返回</span></span><br><span class="line">   serve_file(client, path);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">   <span class="comment">//如果需要则调用</span></span><br><span class="line">   execute_cgi(client, path, method, query_string);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断开与客户端的连接（HTTP特点：无连接）</span></span><br><span class="line"> close(client);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* bad_request函数：返回给客户端这是个错误请求，HTTP状态码400 Bad Request。</span></span><br><span class="line"><span class="comment"> * 参数: 客户端套接字*/</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bad_request</span><span class="params">(<span class="keyword">int</span> client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数原型：int send( SOCKET s,char *buf,int len,int flags );</span></span><br><span class="line"><span class="comment">功能：不论是客户还是服务器应用程序都用send函数来向TCP连接的另一端发送数据。</span></span><br><span class="line"><span class="comment">客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答。</span></span><br><span class="line"><span class="comment">参数一：指定发送端套接字描述符；</span></span><br><span class="line"><span class="comment">参数二：存放应用程序要发送数据的缓冲区；</span></span><br><span class="line"><span class="comment">参数三：实际要发送的数据的字节数；</span></span><br><span class="line"><span class="comment">参数四：一般置为0。*/</span></span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">"HTTP/1.0 400 BAD REQUEST\r\n"</span>);</span><br><span class="line"> send(client, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">"Content-type: text/html\r\n"</span>);</span><br><span class="line"> send(client, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">"\r\n"</span>);</span><br><span class="line"> send(client, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">"&lt;P&gt;Your browser sent a bad request, "</span>);</span><br><span class="line"> send(client, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">"such as a POST without a Content-Length.\r\n"</span>);</span><br><span class="line"> send(client, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Put the entire contents of a file out on a socket.  This function</span></span><br><span class="line"><span class="comment"> * is named after the UNIX "cat" command, because it might have been</span></span><br><span class="line"><span class="comment"> * easier just to do something like pipe, fork, and exec("cat").</span></span><br><span class="line"><span class="comment"> * Parameters: the client socket descriptor</span></span><br><span class="line"><span class="comment"> *             FILE pointer for the file to cat */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">// cat函数：读取服务器上某个文件写到socket套接字。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cat</span><span class="params">(<span class="keyword">int</span> client, FILE *resource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"> <span class="comment">//第一次从文件文件描述符中读取指定内容</span></span><br><span class="line"> fgets(buf, <span class="keyword">sizeof</span>(buf), resource);</span><br><span class="line"> <span class="comment">//循环读取并发送文件内容</span></span><br><span class="line"> <span class="keyword">while</span> (!feof(resource))</span><br><span class="line"> &#123;</span><br><span class="line">  send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">  fgets(buf, <span class="keyword">sizeof</span>(buf), resource);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Inform the client that a CGI script could not be executed.</span></span><br><span class="line"><span class="comment"> * Parameter: the client socket descriptor. */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">// cannot_execute函数：处理发生在执行cgi程序时出现的错误</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cannot_execute</span><span class="params">(<span class="keyword">int</span> client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">"HTTP/1.0 500 Internal Server Error\r\n"</span>);<span class="comment">//500 Internal Server Error //服务器发生不可预期的错误</span></span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">"Content-type: text/html\r\n"</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">"\r\n"</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">"&lt;P&gt;Error prohibited CGI execution.\r\n"</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Print out an error message with perror() (for system errors; based</span></span><br><span class="line"><span class="comment"> * on value of errno, which indicates system call errors) and exit the</span></span><br><span class="line"><span class="comment"> * program indicating an error. */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">// error_die函数：把错误信息写到perror并退出。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *sc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//打印错误信息并退出</span></span><br><span class="line"> <span class="comment">//包含于&lt;stdio.h&gt;,基于当前的 errno 值，在标准错误上产生一条错误消息。参考《TLPI》P49</span></span><br><span class="line"> perror(sc); </span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* 执行CGI脚本</span></span><br><span class="line"><span class="comment"> * 参数: client socket descriptor</span></span><br><span class="line"><span class="comment"> *             path to the CGI script */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">//对于带有参数的get请求和 post请求，这两类并不能直接返回一个静态的html文件，需要cgi</span></span><br><span class="line"><span class="comment">//cgi是common gateway interface（公共网关接口）的简称</span></span><br><span class="line"><span class="comment">//谈一下我对cgi的理解，就是对于不能直接返回静态页面的请求，这些请求一定是需要在服务器上面运行一段代码，然后返回一个结果</span></span><br><span class="line"><span class="comment">//具体一点的谈：</span></span><br><span class="line"><span class="comment">//比如一个 get请求 /index?uid=100,它可能对应的场景是返回id=100用户的页面，这显然不是一个静态的页面，需要动态的生成，然后服务器把这个id=100的参数拿到，去执行本地的一个 xxx.cgi 文件，</span></span><br><span class="line"><span class="comment">//执行这个文件的时候，参数是id=100，然后将执行这个文件的输出返回给浏览器  可以参考 ： http://www.runoob.com/python/python-cgi.html</span></span><br><span class="line"><span class="comment">//cgi理解参考：https://www.zhihu.com/question/19998865</span></span><br><span class="line"><span class="comment">//注意：client是一个文件剧本，在accept_request函数里面，只读了第一行，在execute_cgi函数里面，把剩下的读完</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute_cgi</span><span class="params">(<span class="keyword">int</span> client, <span class="keyword">const</span> <span class="keyword">char</span> *path,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">const</span> <span class="keyword">char</span> *method, <span class="keyword">const</span> <span class="keyword">char</span> *query_string)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"> <span class="keyword">int</span> cgi_output[<span class="number">2</span>];</span><br><span class="line"> <span class="keyword">int</span> cgi_input[<span class="number">2</span>];</span><br><span class="line"> <span class="comment">//pid_t 类型在 Linux 环境编程中用于定义进程 ID，需要引入头文件&lt;sys/types.h&gt;</span></span><br><span class="line"> <span class="comment">//pid_t 等于 int</span></span><br><span class="line"> <span class="keyword">pid_t</span> pid; </span><br><span class="line"> <span class="keyword">int</span> status;</span><br><span class="line"> <span class="keyword">int</span> i;</span><br><span class="line"> <span class="keyword">char</span> c;</span><br><span class="line"> <span class="keyword">int</span> numchars = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">int</span> content_length = <span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//往 buf 中填东西以保证能进入下面的 while</span></span><br><span class="line"> buf[<span class="number">0</span>] = <span class="string">'A'</span>; buf[<span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line"> <span class="comment">//如果是 http 请求是 GET 方法的话读取并忽略请求剩下的内容</span></span><br><span class="line"> <span class="keyword">if</span> (strcasecmp(method, <span class="string">"GET"</span>) == <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">while</span> ((numchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">"\n"</span>, buf))  <span class="comment">/* read &amp; discard headers */</span></span><br><span class="line">   numchars = get_line(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"> <span class="keyword">else</span>    <span class="comment">/* POST */</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="comment">//只有 POST 方法才继续读内容</span></span><br><span class="line">  numchars = get_line(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">  <span class="comment">//这个循环的目的是读出指示 body 长度大小的参数，并记录 body 的长度大小（content_length）。其余的 header 里面的参数一律忽略</span></span><br><span class="line">  <span class="comment">//注意这里只读完 header 的内容，body 的内容没有读</span></span><br><span class="line">  <span class="keyword">while</span> ((numchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">"\n"</span>, buf))</span><br><span class="line">  &#123;</span><br><span class="line">   buf[<span class="number">15</span>] = <span class="string">'\0'</span>; <span class="comment">//// 使用\0进行分割</span></span><br><span class="line">   <span class="keyword">if</span> (strcasecmp(buf, <span class="string">"Content-Length:"</span>) == <span class="number">0</span>)</span><br><span class="line">    content_length = atoi(&amp;(buf[<span class="number">16</span>])); <span class="comment">//记录 body 的长度大小 atoi(const char *nptr):把字符串转换成整型数</span></span><br><span class="line">   numchars = get_line(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果 http 请求的 header 没有指示 body 长度大小的参数，则报错返回</span></span><br><span class="line">  <span class="keyword">if</span> (content_length == <span class="number">-1</span>) &#123;</span><br><span class="line">   bad_request(client);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//发送http200头 ，200 OK表示客户端请求成功</span></span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">"HTTP/1.0 200 OK\r\n"</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//下面这里创建两个管道，用于两个进程间通信</span></span><br><span class="line"> <span class="keyword">if</span> (pipe(cgi_output) &lt; <span class="number">0</span>) &#123;<span class="comment">//输出管道</span></span><br><span class="line">  cannot_execute(client);<span class="comment">// 错误处理</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (pipe(cgi_input) &lt; <span class="number">0</span>) &#123;<span class="comment">//输入管道</span></span><br><span class="line">  cannot_execute(client);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//创建一个子进程</span></span><br><span class="line"> <span class="keyword">if</span> ( (pid = fork()) &lt; <span class="number">0</span> ) &#123;<span class="comment">// fork系统调用用于创建一个新进程，称为子进程，它与进程（称为系统调用fork的进程）同时运行，此进程称为父进程。</span></span><br><span class="line">  cannot_execute(client);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//子进程用来执行 cgi 脚本</span></span><br><span class="line"> <span class="keyword">if</span> (pid == <span class="number">0</span>)  <span class="comment">/* child: CGI script */</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">char</span> meth_env[<span class="number">255</span>];</span><br><span class="line">  <span class="keyword">char</span> query_env[<span class="number">255</span>];</span><br><span class="line">  <span class="keyword">char</span> length_env[<span class="number">255</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//dup2()包含&lt;unistd.h&gt;中，参读《TLPI》P97</span></span><br><span class="line">  <span class="comment">//将子进程的输出由标准输出重定向到 cgi_ouput 的管道写端上</span></span><br><span class="line">  dup2(cgi_output[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">  <span class="comment">//将子进程的输出由标准输入重定向到 cgi_input 的管道读端上</span></span><br><span class="line">  dup2(cgi_input[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  close(cgi_output[<span class="number">0</span>]);<span class="comment">//关闭 cgi_ouput 管道的读端</span></span><br><span class="line">  close(cgi_input[<span class="number">1</span>]); <span class="comment">//关闭cgi_input 管道的写端</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 服务器设置环境变量，即request_method的环境变量</span></span><br><span class="line">  <span class="built_in">sprintf</span>(meth_env, <span class="string">"REQUEST_METHOD=%s"</span>, method);</span><br><span class="line">  <span class="comment">//putenv()包含于&lt;stdlib.h&gt;中，参读《TLPI》P128</span></span><br><span class="line">  <span class="comment">//将这个环境变量加进子进程的运行环境中</span></span><br><span class="line">  putenv(meth_env);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//根据http 请求的不同方法，构造并存储不同的环境变量</span></span><br><span class="line">  <span class="comment">////如果是GET方式设置请求参数环境变量</span></span><br><span class="line">  <span class="keyword">if</span> (strcasecmp(method, <span class="string">"GET"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="built_in">sprintf</span>(query_env, <span class="string">"QUERY_STRING=%s"</span>, query_string);</span><br><span class="line">   putenv(query_env);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; <span class="comment">//如果是POST方式设置内容长度环境变量</span></span><br><span class="line">   <span class="built_in">sprintf</span>(length_env, <span class="string">"CONTENT_LENGTH=%d"</span>, content_length);</span><br><span class="line">   putenv(length_env);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//execl()包含于&lt;unistd.h&gt;中，参读《TLPI》P567</span></span><br><span class="line">  <span class="comment">//执行 cgi 脚本</span></span><br><span class="line">  execl(path, path, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;    <span class="comment">/* parent */</span> <span class="comment">//父进程</span></span><br><span class="line">  </span><br><span class="line">  close(cgi_output[<span class="number">1</span>]);<span class="comment">//父进程则关闭了 cgi_output管道的写端</span></span><br><span class="line">  close(cgi_input[<span class="number">0</span>]);<span class="comment">//父进程则关闭了cgi_input 管道的读端</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果是 POST 方法的话就继续读 body 的内容，并写到 cgi_input 管道里让子进程去读</span></span><br><span class="line">  <span class="keyword">if</span> (strcasecmp(method, <span class="string">"POST"</span>) == <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; content_length; i++) &#123;</span><br><span class="line">    recv(client, &amp;c, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    write(cgi_input[<span class="number">1</span>], &amp;c, <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">//然后从 cgi_output 管道中读子进程的输出，并发送到客户端去</span></span><br><span class="line">  <span class="keyword">while</span> (read(cgi_output[<span class="number">0</span>], &amp;c, <span class="number">1</span>) &gt; <span class="number">0</span>)</span><br><span class="line">   send(client, &amp;c, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//关闭管道</span></span><br><span class="line">  close(cgi_output[<span class="number">0</span>]);</span><br><span class="line">  close(cgi_input[<span class="number">1</span>]);</span><br><span class="line">  <span class="comment">//等待子进程的退出</span></span><br><span class="line">  waitpid(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Get a line from a socket, whether the line ends in a newline,</span></span><br><span class="line"><span class="comment"> * carriage return, or a CRLF combination.  Terminates the string read</span></span><br><span class="line"><span class="comment"> * with a null character.  If no newline indicator is found before the</span></span><br><span class="line"><span class="comment"> * end of the buffer, the string is terminated with a null.  If any of</span></span><br><span class="line"><span class="comment"> * the above three line terminators is read, the last character of the</span></span><br><span class="line"><span class="comment"> * string will be a linefeed and the string will be terminated with a</span></span><br><span class="line"><span class="comment"> * null character.</span></span><br><span class="line"><span class="comment"> * Parameters: the socket descriptor</span></span><br><span class="line"><span class="comment"> *             the buffer to save the data in</span></span><br><span class="line"><span class="comment"> *             the size of the buffer</span></span><br><span class="line"><span class="comment"> * Returns: the number of bytes stored (excluding null) */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_line</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">char</span> *buf, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">char</span> c = <span class="string">'\0'</span>;</span><br><span class="line"> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收\n结束的一行数据或接收满缓冲区</span></span><br><span class="line"> <span class="keyword">while</span> ((i &lt; size - <span class="number">1</span>) &amp;&amp; (c != <span class="string">'\n'</span>))</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="comment">//recv()包含于&lt;sys/socket.h&gt;,参读《TLPI》P1259, </span></span><br><span class="line">  <span class="comment">//读一个字节的数据存放在 c 中</span></span><br><span class="line">  n = recv(sock, &amp;c, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">/* DEBUG printf("%02X\n", c); */</span></span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">//如果接收到了\r符号（回车符）</span></span><br><span class="line">   <span class="keyword">if</span> (c == <span class="string">'\r'</span>)</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="comment">//将下一个字字符预取出来，注意MSG_PEEK本地接收窗口不滑动，下次读取仍然可以读取到该字符</span></span><br><span class="line">    n = recv(sock, &amp;c, <span class="number">1</span>, MSG_PEEK);</span><br><span class="line">    <span class="comment">/* DEBUG printf("%02X\n", c); */</span></span><br><span class="line">     <span class="comment">//如果下一个字符是\n的话，那么接收这个字符</span></span><br><span class="line">    <span class="keyword">if</span> ((n &gt; <span class="number">0</span>) &amp;&amp; (c == <span class="string">'\n'</span>))</span><br><span class="line">     recv(sock, &amp;c, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//不是\n的话，那么将\r替换成\n</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">     c = <span class="string">'\n'</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//字符存入buf，继续读取</span></span><br><span class="line">   buf[i] = c;</span><br><span class="line">   i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">   c = <span class="string">'\n'</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//设置buf字符串结束符</span></span><br><span class="line"> buf[i] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Return the informational HTTP headers about a file. */</span></span><br><span class="line"><span class="comment">/* Parameters: the socket to print the headers on</span></span><br><span class="line"><span class="comment"> *             the name of the file */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">// headers函数：把HTTP响应的头部写到套接字</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">headers</span><span class="params">(<span class="keyword">int</span> client, <span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"> (<span class="keyword">void</span>)filename;  <span class="comment">/* could use filename to determine file type */</span></span><br><span class="line"><span class="comment">//发送http头 http码 服务器信息 内容类型等头部信息</span></span><br><span class="line"> <span class="built_in">strcpy</span>(buf, <span class="string">"HTTP/1.0 200 OK\r\n"</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">strcpy</span>(buf, SERVER_STRING);  <span class="comment">//服务器信息</span></span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">"Content-Type: text/html\r\n"</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">strcpy</span>(buf, <span class="string">"\r\n"</span>); <span class="comment">//到这里就结束了，没有body</span></span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Give a client a 404 not found status message. */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">// not_found函数：处理找不到请求的文件时的情况。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">not_found</span><span class="params">(<span class="keyword">int</span> client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"> <span class="comment">//发送http头 http码 服务器信息 内容类型等头部信息 html提示信息</span></span><br><span class="line"> </span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">"HTTP/1.0 404 NOT FOUND\r\n"</span>);<span class="comment">//404 Not Found //请求资源不存在，eg：输入了错误的URL</span></span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, SERVER_STRING);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">"Content-Type: text/html\r\n"</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">"\r\n"</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="comment">//以下为html提示信息</span></span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">"&lt;HTML&gt;&lt;TITLE&gt;Not Found&lt;/TITLE&gt;\r\n"</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">"&lt;BODY&gt;&lt;P&gt;The server could not fulfill\r\n"</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">"your request because the resource specified\r\n"</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">"is unavailable or nonexistent.\r\n"</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">"&lt;/BODY&gt;&lt;/HTML&gt;\r\n"</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Send a regular file to the client.  Use headers, and report</span></span><br><span class="line"><span class="comment"> * errors to client if they occur.</span></span><br><span class="line"><span class="comment"> * Parameters: a pointer to a file structure produced from the socket</span></span><br><span class="line"><span class="comment"> *              file descriptor</span></span><br><span class="line"><span class="comment"> *             the name of the file to serve */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">// serve_file函数：调用cat函数把服务器文件返回给浏览器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_file</span><span class="params">(<span class="keyword">int</span> client, <span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> FILE *resource = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">int</span> numchars = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"> <span class="comment">//确保 buf 里面有东西，能进入下面的 while 循环</span></span><br><span class="line"> buf[<span class="number">0</span>] = <span class="string">'A'</span>; buf[<span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line"> <span class="comment">//循环作用是读取并忽略掉这个 http 请求后面的所有内容</span></span><br><span class="line"> <span class="keyword">while</span> ((numchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">"\n"</span>, buf))  <span class="comment">/* read &amp; discard headers */</span></span><br><span class="line">  numchars = get_line(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line"> <span class="comment">//打开这个传进来的这个路径所指的文件</span></span><br><span class="line"> resource = fopen(filename, <span class="string">"r"</span>);</span><br><span class="line"> <span class="keyword">if</span> (resource == <span class="literal">NULL</span>) <span class="comment">// //打开失败，发送404</span></span><br><span class="line">  not_found(client);</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="comment">//打开成功后，将这个文件的基本信息封装成 response 的头部(header)并返回</span></span><br><span class="line">  headers(client, filename);</span><br><span class="line">  <span class="comment">//接着把这个文件的内容读出来作为 response 的 body 发送到客户端</span></span><br><span class="line">  cat(client, resource);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> fclose(resource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/*该函数启动监听指定端口上的web连接的过程，包括建立套接字，绑定端口，进行监听等。</span></span><br><span class="line"><span class="comment"> 如果端口为0，则动态分配端口并修改原始端口变量以反映实际端口。</span></span><br><span class="line"><span class="comment"> * 参数: 指向包含要连接的端口的变量的指针</span></span><br><span class="line"><span class="comment"> * 返回: 套接字 */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">startup</span><span class="params">(u_short *port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> httpd = <span class="number">0</span>;</span><br><span class="line"> <span class="comment">//sockaddr_in 是 IPV4的套接字地址结构。定义在&lt;netinet/in.h&gt;,参读《TLPI》P1202</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">name</span>;</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">//创建一个tcp socket，建立socket连接</span></span><br><span class="line"> <span class="comment">//socket()用于创建一个用于 socket 的描述符，函数包含于&lt;sys/socket.h&gt;</span></span><br><span class="line"> httpd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span> (httpd == <span class="number">-1</span>)</span><br><span class="line">  error_die(<span class="string">"socket"</span>);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 填充结构体</span></span><br><span class="line"><span class="comment">//void *memset(void *s, int ch, size_t n);</span></span><br><span class="line"><span class="comment">//函数解释：将s中当前位置后面的n个字节 （typedef unsigned int size_t ）用 ch 替换并返回 s 。</span></span><br><span class="line"><span class="comment">//memset：作用是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法 [1]*/</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;name, <span class="number">0</span>, <span class="keyword">sizeof</span>(name));</span><br><span class="line"> name.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//htons()，ntohs() 和 htonl()包含于&lt;arpa/inet.h&gt;, 参读《TLPI》P1199</span></span><br><span class="line"> <span class="comment">//将*port 转换成以网络字节序表示的16位整数</span></span><br><span class="line"> name.sin_port = htons(*port);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//INADDR_ANY是一个 IPV4通配地址的常量，包含于&lt;netinet/in.h&gt;</span></span><br><span class="line"> <span class="comment">//大多实现都将其定义成了0.0.0.0 参读《TLPI》P1187</span></span><br><span class="line"> name.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 绑定到本地地址port指定端口</span></span><br><span class="line"> <span class="comment">//bind()用于绑定地址与 socket。参读《TLPI》P1153</span></span><br><span class="line"> <span class="comment">//如果传进去的sockaddr结构中的 sin_port 指定为0，这时系统会选择一个临时的端口号</span></span><br><span class="line"> <span class="keyword">if</span> (bind(httpd, (struct sockaddr *)&amp;name, <span class="keyword">sizeof</span>(name)) &lt; <span class="number">0</span>)</span><br><span class="line">  error_die(<span class="string">"bind"</span>);</span><br><span class="line">  </span><br><span class="line"><span class="comment">//如果当前指定的端口是0，则动态随机分配一个端口</span></span><br><span class="line"><span class="comment">//如果调用 bind 后端口号仍然是0，则手动调用getsockname()获取端口号</span></span><br><span class="line"> <span class="keyword">if</span> (*port == <span class="number">0</span>)  <span class="comment">/* if dynamically allocating a port */</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">int</span> namelen = <span class="keyword">sizeof</span>(name);</span><br><span class="line">  <span class="comment">//getsockname()包含于&lt;sys/socker.h&gt;中，参读《TLPI》P1263</span></span><br><span class="line">  <span class="comment">//调用getsockname()获取系统给 httpd 这个 socket 随机分配的端口号</span></span><br><span class="line">  <span class="keyword">if</span> (getsockname(httpd, (struct sockaddr *)&amp;name, &amp;namelen) == <span class="number">-1</span>)</span><br><span class="line">   error_die(<span class="string">"getsockname"</span>);</span><br><span class="line">  *port = ntohs(name.sin_port);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 开始监听</span></span><br><span class="line"> <span class="keyword">if</span> (listen(httpd, <span class="number">5</span>) &lt; <span class="number">0</span>) </span><br><span class="line">  error_die(<span class="string">"listen"</span>);</span><br><span class="line">  <span class="comment">// 返回socket id</span></span><br><span class="line"> <span class="keyword">return</span>(httpd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Inform the client that the requested web method has not been</span></span><br><span class="line"><span class="comment"> * implemented.</span></span><br><span class="line"><span class="comment"> * Parameter: the client socket */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">// unimplemented函数：返回给浏览器表明收到的HTTP请求所用的method不被支持。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unimplemented</span><span class="params">(<span class="keyword">int</span> client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">//发送未实现的请求方法和提示消息给客户端</span></span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">"HTTP/1.0 501 Method Not Implemented\r\n"</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, SERVER_STRING);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">"Content-Type: text/html\r\n"</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">"\r\n"</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">"&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Method Not Implemented\r\n"</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">"&lt;/TITLE&gt;&lt;/HEAD&gt;\r\n"</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">"&lt;BODY&gt;&lt;P&gt;HTTP request method not supported.\r\n"</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">sprintf</span>(buf, <span class="string">"&lt;/BODY&gt;&lt;/HTML&gt;\r\n"</span>);</span><br><span class="line"> send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> server_sock = <span class="number">-1</span>; <span class="comment">//服务器套接字</span></span><br><span class="line"> u_short port = <span class="number">0</span>; <span class="comment">//监听端口</span></span><br><span class="line"> <span class="keyword">int</span> client_sock = <span class="number">-1</span>; <span class="comment">//客户端套接字</span></span><br><span class="line"> <span class="comment">//sockaddr_in 是 IPV4的套接字地址结构。定义在&lt;netinet/in.h&gt;,参读《TLPI》P1202</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_name</span>;</span></span><br><span class="line"> <span class="comment">//socklen_t ：linux头文件#include &lt;sys/socket.h&gt; </span></span><br><span class="line"> <span class="comment">//详细定义：typedef int socklen_t;</span></span><br><span class="line"> <span class="keyword">socklen_t</span> client_name_len = <span class="keyword">sizeof</span>(client_name);</span><br><span class="line"> <span class="comment">//pthread_t：typedef unsigned long int pthread_t;</span></span><br><span class="line"> <span class="comment">//用途：pthread_t用于声明线程ID。</span></span><br><span class="line"> <span class="keyword">pthread_t</span> newthread;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立一个监听套接字，在对应的端口建立httpd服务</span></span><br><span class="line"> server_sock = startup(&amp;port);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"httpd running on port %d\n"</span>, port);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入循环，服务器通过调用accept等待客户端的连接，Accept会以阻塞的方式运行，直到</span></span><br><span class="line"><span class="comment">// 有客户端连接才会返回。连接成功后，服务器启动一个新的线程来处理客户端的请求，处理</span></span><br><span class="line"><span class="comment">// 完成后，重新等待新的客户端请求。</span></span><br><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="comment">//Accept会以阻塞的方式运行，直到有客户端连接才会返回</span></span><br><span class="line">  client_sock = accept(server_sock,</span><br><span class="line">                       (struct sockaddr *)&amp;client_name,</span><br><span class="line">                       &amp;client_name_len);</span><br><span class="line">  <span class="keyword">if</span> (client_sock == <span class="number">-1</span>)</span><br><span class="line">   error_die(<span class="string">"accept"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//对于一个socket连接(即一个http请求)，创建一个线程去处理</span></span><br><span class="line"> <span class="keyword">if</span> (pthread_create(&amp;newthread , <span class="literal">NULL</span>, accept_request, client_sock) != <span class="number">0</span>)</span><br><span class="line">   perror(<span class="string">"pthread_create"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出现意外退出的时候，关闭socket</span></span><br><span class="line"> close(server_sock);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>管程示意图：</p>
<p><img src="http://www.linuxtcpipstack.com/wp-content/uploads/2017/10/117565-20160322111045558-144036450.png" alt="img"></p>
<h4 id="三、-思考总结"><a href="#三、-思考总结" class="headerlink" title="三、 思考总结"></a>三、 思考总结</h4><ol>
<li>对于一个http请求，如果从请求里面解析到关键的字段信息，比如<br> http method，是get，post，put，delete，还是head?<br> url是什么？<br> 如果是post类型的请求，post的参数是在http请求的正文里面的，那么怎么读取出来他们？他们的长度是如何确定的？</li>
</ol>
<p>   判断http 请求header的每一行的标志是 ：\r\n<br>    判断http请求header和请求正文的标志是：两个\r\n （如上图）<br>    对于，一个post请求，请求的正文里面是post的请求数据，header里面的content-length指明了post请求的数据的长度。</p>
<ol start="2">
<li><p>对于带有参数的get方法，和post方法，你的服务器如何去处理？</p>
<p>带有参数的get请求，和post请求，服务器没有办法简单的返回一个静态的文件，服务器需要在服务器端将相应的页面“计算”出来，然后返回给浏览器。</p>
<p>假如，浏览器发送了一个请求 /index?id=100，请求id=100的人的主页<br> 那么，服务器需要“计算”出来id=100的这个人的主页的的页面。这个就需要cgi来帮忙了，cgi可以理解为在服务器端可以执行的小脚本。服务器收到这个请求之后，执行index.cgi （这个文件是提前写好了，专门来处理这样的请求) ，服务器执行index.cgi ，参数是id=100，然后“计算”出网页的数据，返回给浏览器。</p>
</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Joe_Feng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/03/20/TinyHttp/">http://yoursite.com/2020/03/20/TinyHttp/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Joe's blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/TinyHttp/">TinyHttp</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2020/03/15/进程、线程的同步与通信/"><span>进程的互斥、同步、通信</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'afa546c23633846e93ae',
  clientSecret: '364b205cda14b8655b23a2038f1be33e9f3a3fdf',
  repo: 'Joe-Feng.github.io',
  owner: 'Joe-Feng',
  admin: 'Joe-Feng',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(http://pic1.win4000.com/wallpaper/8/565d5415d62dd.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By Joe_Feng</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>