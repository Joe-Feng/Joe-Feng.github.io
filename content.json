{"meta":{"title":"Joe's blog","subtitle":"It's better to burn out than to fade away","description":null,"author":"Joe_Feng","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-06-07T04:23:11.000Z","updated":"2019-06-07T04:32:34.471Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"slides","date":"2019-06-08T08:03:49.000Z","updated":"2019-06-08T08:04:18.726Z","comments":true,"path":"slides/index.html","permalink":"http://yoursite.com/slides/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-06-08T03:54:30.000Z","updated":"2019-06-08T03:54:49.765Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"生活杂谈","date":"2019-06-08T03:44:04.000Z","updated":"2019-06-08T03:44:27.961Z","comments":true,"path":"生活杂谈/index.html","permalink":"http://yoursite.com/生活杂谈/index.html","excerpt":"","text":""},{"title":"读书笔记","date":"2019-06-08T03:39:31.000Z","updated":"2019-06-08T03:41:56.704Z","comments":true,"path":"读书笔记/index.html","permalink":"http://yoursite.com/读书笔记/index.html","excerpt":"","text":""},{"title":"项目实战","date":"2019-06-08T03:40:59.000Z","updated":"2019-06-08T03:41:39.338Z","comments":true,"path":"项目实战/index.html","permalink":"http://yoursite.com/项目实战/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"进程、线程的同步与通信","date":"2020-04-14T04:39:20.060Z","updated":"2020-04-14T09:20:57.620Z","comments":true,"path":"2020/04/14/进程、线程的同步与通信/","link":"","permalink":"http://yoursite.com/2020/04/14/进程、线程的同步与通信/","excerpt":"","text":"进程的互斥、同步、通信进程的互斥、同步、通信都是基于竞争和协作关系而存在的。 为了解决进程间竞争关系（间接制约关系）而引入进程互斥； 为了解决进程间松散的协作关系( 直接制约关系)而引入进程同步； 为了解决进程间紧密的协作关系而引入进程通信。 进程的互斥资源竞争出现了两个控制问题： 一个是死锁 （deadlock ）问题，一组进程如果都获得了部分资源，还想要得到其他进程所占有的资源，最终所有的进程将陷入死锁。 另一个是饥饿（starvation ）问题，这是指这样一种情况：一个进程由于其他进程总是优先于它而被无限期拖延。 进程的互斥（mutual exclusion ）是解决进程间竞争关系( 间接制约关系) 的手段。 进程互斥指若干个进程要使用同一共享资源时，任何时刻最多允许一个进程去使用，其他要使用该资源的进程必须等待，直到占有资源的进程释放该资源。 进程的同步进程的同步（Synchronization）是解决进程间协作关系( 直接制约关系) 的手段。 进程间的同步是双方不知道对方名字的间接协作，例如，通过共享访问一个缓冲区进行松散式协作； 进程同步指两个以上进程基于某个条件来协调它们的活动。一个进程的执行依赖于另一个协作进程的消息或信号，当一个进程没有得到来自于另一个进程的消息或信号时则需等待，直到消息或信号到达才被唤醒。 进程互斥关系是一种特殊的进程同步关系，即逐次使用互斥共享资源，也是对进程使用资源次序上的一种协调。 进程的同步方法：（进程互斥关系是一种特殊的进程同步关系，所以也可用于进程的互斥） 信号量 互斥量 管程 进程的通信并发进程之间的交互必须满足两个基本要求：同步和通信。 进程竞争资源时要实施互斥，互斥是一种特殊的同步，实质上需要解决好进程同步问题，进程同步是一种进程通信，通过修改信号量，进程之间可建立起联系，相互协调运行和协同工作。但是信号量与PV操作只能传递信号，没有传递数据的能力。有些情况下进程之间交换的信息量虽很少，例如，仅仅交换某个状态信息，但很多情况下进程之间需要交换大批数据，例如，传送一批信息或整个文件，这可以通过一种新的通信机制来完成，进程之间互相交换信息的工作称之为进程通信IPC （InterProcess Communication）（主要是指大量数据的交换）。 进程的通信方式进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。 管道： 管道主要包括无名管道和命名管道:管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信 1.1.普通管道PIPE： 1)它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端 2)它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间） 3)它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。 1.2 命名管道FIFO： 1)FIFO可以在无关的进程之间交换数据 2)FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。 系统IPC： 2.1 消息队列 消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。 (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息； 特点： 1)消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。 2)消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。 3)消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。 2.2 信号量semaphore 信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。 特点： 1)信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。 2)信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。 3)每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。 4)支持信号量组。 2.3 信号signal 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。 signal，又简称为信号（软中断信号）用来通知进程发生了异步事件。 原理： 一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是进程间通信机制中唯一的异步通信机制，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。进程之间可以互相通过系统调用kill发送软中断信号。内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。信号机制除了基本通知功能外，还可以传递附加信息。 2.4 共享内存（Shared Memory） 它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等 特点： 1)共享内存是最快的一种IPC，因为进程是直接对内存进行存取 2)因为多个进程可以同时操作，所以需要进行同步 3)信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问 套接字SOCKET： socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。 线程的通信方式（查阅了很多资料，把同步方式和通信方式混为一谈，那这里也把这两种当做一回事吧） 临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问； 互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问 信号量Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。 事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作 信号量与互斥量的区别： 信号量：多线程同步使用的；一个线程完成某个动作后通过信号告诉别的线程，别的线程才可以执行某些动作； 互斥量：多线程互斥使用的；一个线程占用某个资源，那么别的线程就无法访问，直到该线程离开，其他线程才可以访问该资源 互斥锁的作用就是互斥，mutual exclusive，是用来保护临界区(critical section)的。所谓临界区就是代码的一个区间，如果两个线程同时执行就有可能出问题，所以需要互斥锁来保护。 信号量（semaphore）是一种更高级的同步机制，mutex可以说是semaphore在仅取值0/1时的特例。Semaphore可以有更多的取值空间，用来实现更加复杂的同步，而不单单是线程间互斥。 1、互斥量用于线程的互斥，信号量用于线程的同步： 互斥：指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排他性。但是互斥无法限制访问者对资源的访问顺序，所以访问是无序的； 同步：指在互斥的基础上（多数情况），通过其他机制实现访问者对资源的有序访问。大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况指可以允许多个访问者同时访问资源。 2、互斥量值只能是0/1，信号量值可以为非负整数： 一个互斥量只能用于一个资源的互斥访问不能实现多个资源的多线程互斥问题； 一个信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量时，也可以完成一个资源的互斥访问； 3、互斥量的加锁和解锁必须由同一线程分别对应使用；而信号量可以由一个线程释放，另外一个线程得到。","categories":[],"tags":[]},{"title":"","slug":"死锁 活锁 饥饿","date":"2020-04-14T04:36:16.807Z","updated":"2020-04-14T09:21:51.993Z","comments":true,"path":"2020/04/14/死锁 活锁 饥饿/","link":"","permalink":"http://yoursite.com/2020/04/14/死锁 活锁 饥饿/","excerpt":"","text":"死锁 活锁 饥饿死锁（争来争去 谁也得不到）死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 死锁发生的条件 互斥条件：线程对资源的访问是排他性的，如果一个线程对占用了某资源，那么其他线程必须处于等待状态，直到资源被释放。 请求和保持条件：线程T1至少已经保持了一个资源R1占用,但又提出对另一个资源R2请求，而此时，资源R2被其他线程T2占用，于是该线程T1也必须等待，但又对自己保持的资源R1不释放。 不剥夺条件：线程已获得的资源，在未使用完之前，不能被其他线程剥夺，只能在使用完以后由自己释放。 环路等待条件：在死锁发生时，必然存在一个“进程-资源环形链”，即：{p0,p1,p2,…pn},进程p0（或线程）等待p1占用的资源，p1等待p2占用的资源，pn等待p0占用的资源。（最直观的理解是，p0等待p1占用的资源，而p1而在等待p0占用的资源，于是两个进程就相互等待） 活锁（让来让去 谁都不拥有）活锁：是指线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源。 关于“死锁与活锁”的比喻： 死锁：迎面开来的汽车A和汽车B过马路，汽车A得到了半条路的资源（满足死锁发生条件1：资源访问是排他性的，我占了路你就不能上来，除非你爬我头上去），汽车B占了汽车A的另外半条路的资源，A想过去必须请求另一半被B占用的道路（死锁发生条件2：必须整条车身的空间才能开过去，我已经占了一半，尼玛另一半的路被B占用了），B若想过去也必须等待A让路，A是辆兰博基尼，B是开奇瑞QQ的屌丝，A素质比较低开窗对B狂骂：快给老子让开，B很生气，你妈逼的，老子就不让（死锁发生条件3：在未使用完资源前，不能被其他线程剥夺），于是两者相互僵持一个都走不了（死锁发生条件4：环路等待条件），而且导致整条道上的后续车辆也走不了。 活锁：马路中间有条小桥，只能容纳一辆车经过，桥两头开来两辆车A和B，A比较礼貌，示意B先过，B也比较礼貌，示意A先过，结果两人一直谦让谁也过不去。 饥饿（排多久 都轮不到自己）饥饿：是指如果线程T1占用了资源R，线程T2又请求封锁R，于是T2等待。T3也请求资源R，当T1释放了R上的封锁后，系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后，系统又批准了T4的请求……，T2可能永远等待。 关于”饥饿“的比喻： 在“首堵”北京的某一天，天气阴沉，空气中充斥着雾霾和地沟油的味道，某个苦逼的临时工交警正在处理塞车，有两条道A和B上都堵满了车辆，其中A道堵的时间最长，B相对相对堵的时间较短，这时，前面道路已疏通，交警按照最佳分配原则，示意B道上车辆先过，B道路上过了一辆又一辆，A道上排队时间最长的确没法通过，只能等B道上没有车辆通过的时候再等交警发指令让A道依次通过，这也就是ReentrantLock显示锁里提供的不公平锁机制（当然了，ReentrantLock也提供了公平锁的机制，由用户根据具体的使用场景而决定到底使用哪种锁策略），不公平锁能够提高吞吐量但不可避免的会造成某些线程的饥饿。 参考：https://www.cnblogs.com/ktgu/p/3529143.html","categories":[],"tags":[]},{"title":"","slug":"第四次学习","date":"2020-02-19T12:13:00.826Z","updated":"2019-06-01T13:15:48.690Z","comments":true,"path":"2020/02/19/第四次学习/","link":"","permalink":"http://yoursite.com/2020/02/19/第四次学习/","excerpt":"","text":"添加远程库，从本地库推送到远程库 在Github上新建一个仓库，复制仓库地址 一整套流程如下： 1234567891011mkdir [文件夹名]cd [文件夹名]git initvim [文件名]git add [文件名]git commit -m &quot;description&quot; [文件名]git remote -v //查看是否关联了远程库git remote add origin [远程库链接]git remote -v git push -u origin master //由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 Notice: 必须先将文件提交到本地库，才能推送，本地库为空会报错 ​ 错误提示：error: src refspec master does not match any 2 删除关联：git remote rm origin 克隆操作操作： 1git clone [远程地址] 效果： 把远程库下载到本地 创建origin远程库别名，即进行了与远程库的连接（连接到的是邀请加入的库的地址） 初始化本地库，即生成了.git文件 邀请成员参与这里参与的是一个项目，也就是一个远程库 必须先邀请，邀请到的成员才能将修改的文件push到本地库 远程库的修改与拉取在创建远程库的目录下操作 pull=fetch+merge 1234git fetch origin master [远程库地址别名] [远程分支名]//将远程库文件下载下来，并没有改变该目录下文件git merge origin/mastergit pull oringin master 解决冲突要点 如果不是基于 GitHub 远程库的最新版所做的修改， 不能推送， 必须先拉取。 拉取下来后如果进入冲突状态， 则按照“分支冲突解决” 操作解决即可。 跨团队合作修改人员做的工作： Fork 拉取到本地，修改 推送到远端 new pull request create pull request 发起人做的工作： 对话 审核代码 file changed 合并代码 merge pull request comfirm merge 将远程库拉取到本地","categories":[],"tags":[]},{"title":"","slug":"第三次学习-续","date":"2020-02-19T12:12:58.030Z","updated":"2019-06-01T06:17:12.569Z","comments":true,"path":"2020/02/19/第三次学习-续/","link":"","permalink":"http://yoursite.com/2020/02/19/第三次学习-续/","excerpt":"","text":"bug分支Q:假如现在的Bug你还没有解决，而上边又给你派了一个新的Bug，而这个Bug相比较现在正在苦思冥想的Bug比较容易解决。你想先解决新的Bug，可是之前的Bug还没有解决完而不能提交。怎么办? 解决方法： Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作： 1git stash 解决完bug以后，切换回这个分支 查看保存的工作现场：git stash list 恢复工作现场： ​ 方法1：git stash pop //恢复的同时把stash内容也删了 ​ 方法2： ​ git stash apply [stash标号] //恢复现场 ​ git stash drop//删除stash内容 Feature 分支这个分支和普通分支没啥区别，是一种管理分支的策略 添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。 开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除。","categories":[],"tags":[]},{"title":"","slug":"第三次学习","date":"2020-02-19T12:12:53.734Z","updated":"2019-06-01T06:17:09.419Z","comments":true,"path":"2020/02/19/第三次学习/","link":"","permalink":"http://yoursite.com/2020/02/19/第三次学习/","excerpt":"","text":"查看历史记录git log 显示最完整 多屏显示控制： ​ 空格向下翻页 ​ b 向上翻页 ​ q 退出 git log –pretty =oneline git log –oneline 将哈希值缩短 git reflog 添加了移动到当前版本需要的步数 前进后退 基于索引值（推荐）： 1git reset --hard [局部索引值] 不必关心是前进还是后退，只要知道是到了哪个版本 使用^符号：只能往后退，不能往前 1git reset --hard HEAD^ （有几个^，说明后退几步） 使用~符号：只能后退 1git reset --had HEAD~n 后退n步 tail -n 3 [文件名] :查看文件的最后三行 reset命令的三个参数的区别 –soft:仅在本地库移动HEAD 本地库向后移 –mixed:在本地库移动HEAD；重置暂存区 本地库和暂存区都向后移动 –hard:在本地库移动HEAD；重置暂存区；重置工作区 找回删除的文件 工作区文件删除+恢复 123rm [flile name] //删除工作区文件git checkout -- [filename] //恢复工作区文件 工作区和存储区文件删除+恢复 1234rm [flile name] git add [flile name] //删除存储区的文件git reset --hard HEAD //恢复到上一个版本 永久删除文件+恢复 12345rm [flile name] //删除git add [flile name]git commit -m &quot;description&quot; [flile name] //删除本地库文件git reset --hard [历史记录哈希值] 操作：git reset –hard [指针位置] ​ 删除操作已经提交到了本地库：指针位置指向历史记录 ​ 删除操作尚未提交到本地库：指针位置使用HEAD 撤销修改 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 文件比较 git diff [文件名]：将工作区文件与暂存区进行比较 git diff [本地库中历史版本]【文件名】：工作区中和本地历史库版本比较 不带文件名会比较多个文件 123git diff good.txtgit diff HEAD(HEAD^) good.txtgit diff 分支hot-fix(服务器不停)/cool-fix（服务器停止下修复） 分支操作1234567891011121314151617181920212223242526272829创建分支：git branch[分支名]查看分支名：git branch -v切换分支: git checkout[分支名]创建+切换分支：git checkout -b &lt;name&gt;git branch -d &lt;branchName&gt;:删除一个名字为branchName的分支。如果该分支有提交未进行合并，则会删除失败。删除分支时必须切换到master，不然会报错git branch -D &lt;branchName&gt;:强制删除一个名字为branchName 的分支。如果该分支有提交未进行合并，也会删除成功。看到分支合并图:git log --graphgit log --graph --pretty=oneline --abbrev-commit` //只会显示图，哈希值，提交信息合并分支：第一步：切换到接收修改的（被合并，增加新内容）上git checkout[被合并分支名]第二步：执行merge命令git merge[有新内容的分支名]解决冲突：第一步： 编辑文件， 删除特殊符号第二步： 把文件修改到满意的程度， 保存退出第三步： git add [文件名]第四步： git commit -m &quot;日志信息&quot;（此时 commit 一定不能带具体文件名） Q: git 切换分支时会把未add或未commit的内容带过去(在重新创建一个分支之后，如果不做提交操作的话，直接切换到主分支之后也是可以看到其他分支做的修改操作) A: (https://blog.csdn.net/stpeace/article/details/84351160) 因为未add的内容不属于任何一个分支， 未commit的内容也不属于任何一个分支。 也就是说，对于所有分支而言， 工作区和暂存区是公共的。 要想在分支间切换， 又不想又上述影响， 怎么办呢？ git stash搞起。要注意，在当前分支git stash的内容， 在其他分支也可以git stash pop出来，为什么？ 因为：工作区和暂存区是公共的。 解决方法： 分支管理策略 fast forward模式：也就是一般使用的 git merge [分支名]，这种模式合并完以后看不到分支的痕迹，只能看到master 强制禁用Fast forward模式： Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息 语法：git merge --no-ff -m &quot;merge with no-ff&quot; dev ​ //合并要创建一个新的commit，所以加上-m参数，把commit描述写进去 在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 查看分支图：git log --graph --pretty=oneline --abbrev-commit //只会显示图，哈希值，提交信息","categories":[],"tags":[]},{"title":"","slug":"python学习","date":"2020-02-17T06:59:13.699Z","updated":"2020-02-17T13:44:44.707Z","comments":true,"path":"2020/02/17/python学习/","link":"","permalink":"http://yoursite.com/2020/02/17/python学习/","excerpt":"","text":"元组的记数函数 元组名.count(x): x在元组中出现的次数","categories":[],"tags":[]},{"title":"","slug":"Python学习笔记-基本数据类型","date":"2020-02-09T04:11:41.098Z","updated":"2020-02-09T06:06:14.225Z","comments":true,"path":"2020/02/09/Python学习笔记-基本数据类型/","link":"","permalink":"http://yoursite.com/2020/02/09/Python学习笔记-基本数据类型/","excerpt":"","text":"变量的定义与赋值 Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建 等号（=）用来给变量赋值。可以同时给多个变量赋相同的值，也可以同时赋给不同类型的值 12345678910111213141516171819202122#单个变量赋值a = 1b = 2.5c = 'xiaoming'print('a=', a)print('b=', b)print('c=', c)'''结果为a= 1b= 2.5c= xiaoming'''#多个变量赋值a, b , c = 1, 2.1, 'robot'print(a,b,c) #print()可以同时输出几个变量，并且以空格隔开print(a)print(b)print(c)#结果：1 2.1 robot 标准数据类型Number（数字）:int, float, bool, complex（复数） String（字符串） List（列表） Tuple（元组） Set（集合） Dictionary（字典） 不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）； 可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。 ​ 可变数据与不可变数据的理解：https://blog.csdn.net/dan15188387481/article/details/49864613 Number 在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。 内置的 type() 函数可以用来查询变量所指的对象类型,还可以用 isinstance 来判断： isinstance 和 type 的区别在于： type()不会认为子类是一种父类类型。 isinstance()会认为子类是一种父类类型。 注意： 1、Python可以同时为多个变量赋值，如a, b = 1, 2。 2、一个变量可以通过赋值指向不同类型的对象。 3、数值的除法包含两个运算符：/ 返回一个浮点数，// 返回一个整数。 4、在混合计算时，Python会把整型转换成为浮点数。","categories":[],"tags":[]},{"title":"","slug":"markdown learning","date":"2020-02-08T04:00:23.038Z","updated":"2020-02-08T04:56:04.936Z","comments":true,"path":"2020/02/08/markdown learning/","link":"","permalink":"http://yoursite.com/2020/02/08/markdown learning/","excerpt":"","text":"Markdown 语法1. 标题的书写标题二级标题三级标题四级标题五级标题2. 正文书写正文直接输入就可以了 换行注意：需要在代码中实际空一行，直接换行的话，输出的是没有换行的 3. 代码块123代码块的书写在代码开头和结尾处写 123```pythonprint(&quot;hello word&quot;) 4. 正文中的代码正文中的代码通过输入``框出 例如 print(&quot;hello word&quot;) 5. 列表 1 有序列表 输入一个数字，然后加一个句号.(英文)，然后空格，按回车后会自动生成下一个 多级标题：输入一个数字，然后加一个句号.(英文)，然后空格，再按tab，一次缩进一级 1 第一级 1 第二级 1 第三级 加 tab 的话 无序列表 输入 - 然后空格 加 tab 可以显示为代码块格式 多级无序列表 再来一级 再来一级 加粗 **文字**倾斜 *文字*加粗加倾斜 ***文字***","categories":[],"tags":[]},{"title":"C++小项目-飞机大战","slug":"C-小项目-飞机大战","date":"2019-06-08T12:43:14.000Z","updated":"2019-06-08T12:44:14.832Z","comments":true,"path":"2019/06/08/C-小项目-飞机大战/","link":"","permalink":"http://yoursite.com/2019/06/08/C-小项目-飞机大战/","excerpt":"","text":"","categories":[{"name":"项目实战","slug":"项目实战","permalink":"http://yoursite.com/categories/项目实战/"}],"tags":[]},{"title":"大学四年，我到底经历了什么？","slug":"大学四年，我到底经历了什么？","date":"2019-06-08T12:39:13.000Z","updated":"2019-06-08T12:40:55.088Z","comments":true,"path":"2019/06/08/大学四年，我到底经历了什么？/","link":"","permalink":"http://yoursite.com/2019/06/08/大学四年，我到底经历了什么？/","excerpt":"","text":"大学四年，我到底经历了什么？","categories":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"http://yoursite.com/categories/生活杂谈/"}],"tags":[]},{"title":"富爸爸穷爸爸读书笔记","slug":"富爸爸穷爸爸读书笔记","date":"2019-06-08T12:12:52.000Z","updated":"2019-06-08T12:13:31.859Z","comments":true,"path":"2019/06/08/富爸爸穷爸爸读书笔记/","link":"","permalink":"http://yoursite.com/2019/06/08/富爸爸穷爸爸读书笔记/","excerpt":"","text":"","categories":[{"name":"读书","slug":"读书","permalink":"http://yoursite.com/categories/读书/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://yoursite.com/tags/读书/"}]},{"title":"Test slide","slug":"Test-slide","date":"2019-06-08T07:48:56.000Z","updated":"2019-06-08T12:15:10.264Z","comments":true,"path":"2019/06/08/Test-slide/","link":"","permalink":"http://yoursite.com/2019/06/08/Test-slide/","excerpt":"","text":"slide1This fuction is pretty cool! I enjoy it! slide2I like this theme! The author is very diao!","categories":[],"tags":[]},{"title":"曾国藩传（张宏杰著）读书笔记","slug":"曾国藩传—（张宏杰）读书笔记","date":"2019-06-07T11:40:55.000Z","updated":"2019-06-08T12:13:49.911Z","comments":true,"path":"2019/06/07/曾国藩传—（张宏杰）读书笔记/","link":"","permalink":"http://yoursite.com/2019/06/07/曾国藩传—（张宏杰）读书笔记/","excerpt":"","text":"脉络梳理读书感悟书摘行动指南","categories":[{"name":"读书","slug":"读书","permalink":"http://yoursite.com/categories/读书/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://yoursite.com/tags/读书/"}]},{"title":"Git学习笔记（二）","slug":"Git学习笔记（二）","date":"2019-06-07T11:37:14.000Z","updated":"2019-06-08T12:15:29.927Z","comments":true,"path":"2019/06/07/Git学习笔记（二）/","link":"","permalink":"http://yoursite.com/2019/06/07/Git学习笔记（二）/","excerpt":"","text":"配置签名","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Git学习笔记（一）","slug":"Git学习笔记（一）","date":"2019-06-07T04:09:26.000Z","updated":"2019-06-08T12:15:20.560Z","comments":true,"path":"2019/06/07/Git学习笔记（一）/","link":"","permalink":"http://yoursite.com/2019/06/07/Git学习笔记（一）/","excerpt":"","text":"Linux命令： cd 目录/ ：进入一个目录 ll : 显示目录下的文件 ls -lA: 显示目录下的隐藏文件 ll|less: 分屏显示 q:退出 git本地库初始化进入想要创建的文件下操作 1234567891011$mkdir learngit：新建一个文件夹learngit$cd learngit/:进入learngit文件下操作$git init :初始化了一个git仓库.git文件（这个文件是隐藏的，需要用ls -lA 查看；git 目录中存放的是本地库相关的子目录和文件， 不要删除， 也不要胡乱修改 ）$pwd :显示.git文件完整路径","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]}]}