{"meta":{"title":"Joe's blog","subtitle":"It's better to burn out than to fade away","description":null,"author":"Joe_Feng","url":"http://yoursite.com","root":"/"},"pages":[{"title":"slides","date":"2019-06-08T08:03:49.000Z","updated":"2019-06-08T08:04:18.726Z","comments":true,"path":"slides/index.html","permalink":"http://yoursite.com/slides/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-06-07T04:23:11.000Z","updated":"2019-06-07T04:32:34.471Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-06-08T03:54:30.000Z","updated":"2019-06-08T03:54:49.765Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"读书笔记","date":"2019-06-08T03:39:31.000Z","updated":"2019-06-08T03:41:56.704Z","comments":true,"path":"读书笔记/index.html","permalink":"http://yoursite.com/读书笔记/index.html","excerpt":"","text":""},{"title":"生活杂谈","date":"2019-06-08T03:44:04.000Z","updated":"2019-06-08T03:44:27.961Z","comments":true,"path":"生活杂谈/index.html","permalink":"http://yoursite.com/生活杂谈/index.html","excerpt":"","text":""},{"title":"项目实战","date":"2019-06-08T03:40:59.000Z","updated":"2019-06-08T03:41:39.338Z","comments":true,"path":"项目实战/index.html","permalink":"http://yoursite.com/项目实战/index.html","excerpt":"","text":""}],"posts":[{"title":"TinyHttp源码剖析","slug":"TinyHttp","date":"2020-03-20T12:43:14.000Z","updated":"2020-04-16T10:11:17.114Z","comments":true,"path":"2020/03/20/TinyHttp/","link":"","permalink":"http://yoursite.com/2020/03/20/TinyHttp/","excerpt":"TinyHttp源码剖析一、 TinyHttp源码剖析预备知识——HTTP协议1. HTTP协议概念HTTP协议，即超文本传输协议(Hypertext transfer protocol)。是一种详细规定了浏览器和万维网(WWW = World Wide Web)服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。 HTTP协议是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。 HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。 在Internet中所有的传输都是通过TCP/IP进行的。HTTP协议作为TCP/IP模型中应用层的协议也不例外。HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。 HTTP默认的端口号为80，HTTPS的端口号为443。 浏览网页是HTTP的主要应用，但是这并不代表HTTP就只能应用于网页的浏览。HTTP是一种协议，只要通信的双方都遵守这个协议，HTTP就能有用武之地。比如咱们常用的QQ，迅雷这些软件，都会使用HTTP协议(还包括其他的协议)。 2. 特点 HTTP 0.9和1.0使用非持续连接：限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。HTTP 1.1使用持续连接：不必为每个web对象创建一个新的连接，一个连接可以传送多个对象，采用这种方式可以节省传输时间。 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。","text":"TinyHttp源码剖析一、 TinyHttp源码剖析预备知识——HTTP协议1. HTTP协议概念HTTP协议，即超文本传输协议(Hypertext transfer protocol)。是一种详细规定了浏览器和万维网(WWW = World Wide Web)服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。 HTTP协议是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。 HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。 在Internet中所有的传输都是通过TCP/IP进行的。HTTP协议作为TCP/IP模型中应用层的协议也不例外。HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。 HTTP默认的端口号为80，HTTPS的端口号为443。 浏览网页是HTTP的主要应用，但是这并不代表HTTP就只能应用于网页的浏览。HTTP是一种协议，只要通信的双方都遵守这个协议，HTTP就能有用武之地。比如咱们常用的QQ，迅雷这些软件，都会使用HTTP协议(还包括其他的协议)。 2. 特点 HTTP 0.9和1.0使用非持续连接：限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。HTTP 1.1使用持续连接：不必为每个web对象创建一个新的连接，一个连接可以传送多个对象，采用这种方式可以节省传输时间。 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。 协议的状态是指下一次传输可以“记住”这次传输信息的能力。 http是不会为了下一次连接而维护这次连接所传输的信息,为了保证服务器内存。 比如客户获得一张网页之后关闭浏览器，然后再一次启动浏览器，再登陆该网站，但是服务器并不知道客户关闭了一次浏览器。 由于Web服务器要面对很多浏览器的并发访问，为了提高Web服务器对并发访问的处理能力，在设计HTTP协议时规定Web服务器发送HTTP应答报文和文档时，不保存发出请求的Web浏览器进程的任何状态信息。这有可能出现一个浏览器在短短几秒之内两次访问同一对象时，服务器进程不会因为已经给它发过应答报文而不接受第二期服务请求。由于Web服务器不保存发送请求的Web浏览器进程的任何信息，因此HTTP协议属于无状态协议（Stateless Protocol）。 HTTP协议是无状态的和Connection: keep-alive的区别： 无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。 HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。 从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。 Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。 3. 工作流程1）首先客户机与服务器需要建立连接（TCP连接-三次握手）。只要单击某个超级链接，HTTP的工作开始。 2）建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。 例如：GET / HTTP/1.1\\r\\nHost: www.sina.com.cn\\r\\nConnection: close\\r\\n\\r\\n 3）服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。 4）客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。 如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。 4. HTTP报文的结构HTTP报文分为两类：请求报文（从客户向服务器发送），响应报文（从服务器到客户的应答） 请求报文和响应报文都是由三部分组成的：开始行、首部行、实体主体 请求报文和响应报文的区别在于开始行的不同，请求报文的开始行叫请求行，响应报文的开始行叫状态行 12345678910111213141516HTTP之状态码状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:1xx：指示信息--表示请求已接收，继续处理2xx：成功--表示请求已被成功接收、理解、接受3xx：重定向--要完成请求必须进行更进一步的操作4xx：客户端错误--请求有语法错误或请求无法实现5xx：服务器端错误--服务器未能实现合法的请求常见状态码：200 OK //客户端请求成功400 Bad Request //客户端请求有语法错误，不能被服务器所理解401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用403 Forbidden //服务器收到请求，但是拒绝提供服务404 Not Found //请求资源不存在，eg：输入了错误的URL500 Internal Server Error //服务器发生不可预期的错误503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常 5. 请求方法请求方法用来标明客户端希望服务器对资源执行的动作。 HTTP服务器至少应该实现GET和HEAD方法，其他方法都是可选的 方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed）；当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。 GET：向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在web app.中。其中一个原因是GET可能会被网络蜘蛛等随意访问。 HEAD ：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。 POST ：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 PUT ：将请求的主体部分存储在服务器中，如上传文件 DELETE ：请求删除服务器上指定的文档 TRACE ：追踪请求到达服务器中间经过的代理服务器 OPTIONS ：请求服务器返回对指定资源支持使用的请求方法 GET和POST的区别： 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）； 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据） 1、GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中。 2、GET提交的数据大小有限制，最多只能有1024字节（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制。 3、GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。 4、GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。 6. Http与Https的区别1）HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS加密后的，HTTPS具有更高的安全性 2）HTTPS在TCP三次握手阶段之后，还需要进行SSL 的handshake，协商加密使用的对称加密密钥 3）HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书 4）HTTP协议端口是80，HTTPS协议端口是443 HTTPS优点： HTTPS传输数据过程中使用密钥进行加密，所以安全性更高 HTTPS协议可以认证用户和服务器，确保数据发送到正确的用户和服务器 HTTPS缺点： HTTPS握手阶段延时较高：由于在进行HTTP会话之前还需要进行SSL握手，因此HTTPS协议握手阶段延时增加 HTTPS部署成本高：一方面HTTPS协议需要使用证书来验证自身的安全性，所以需要购买CA证书；另一方面由于采用HTTPS协议需要进行加解密的计算，占用CPU资源较多，需要的服务器配置或数目高 7. 如何理解套接字？传输层实现端到端的通信，因此，每一个传输层连接有两个端点。那么，传输层连接的端点是什么呢？不是主机，不是主机的IP地址，不是应用进程，也不是传输层的协议端口。传输层连接的端点叫做套接字（socket）。根据RFC793的定义：端口号拼接到IP地址就构成了套接字。所谓套接字，实际上是一个通信端点，每个套接字都有一个套接字序号，包括主机的IP地址与一个16位的主机端口号，即形如（主机IP地址：端口号）。例如，如果IP地址是210.37.145.1，而端口号是23，那么得到套接字就是（210.37.145.1：23）。 总之，套接字Socket=（IP地址：端口号），套接字的表示方法是点分十进制的IP地址后面写上端口号，中间用冒号或逗号隔开。每一个传输层连接唯一地被通信两端的两个端点（即两个套接字）所确定。 套接字可以看成是两个网络应用程序进行通信时，各自通信连接中的一个端点。通信时，其中的一个网络应用程序将要传输的一段信息写入它所在主机的Socket中，该Socket通过网络接口卡的传输介质将这段信息发送给另一台主机的Socket中，使这段信息能传送到其他程序中。因此，两个应用程序之间的数据传输要通过套接字来完成。 在网络应用程序设计时，由于TCP/IP的核心内容被封装在操作系统中，如果应用程序要使用TCP/IP，可以通过系统提供的TCP/IP的编程接口来实现。在Windows环境下，网络应用程序编程接口称作Windows Socket。为了支持用户开发面向应用的通信程序，大部分系统都提供了一组基于TCP或者UDP的应用程序编程接口（API），该接口通常以一组函数的形式出现，也称为套接字（Socket）。 能够唯一标示网络中的进程后，它们就可以利用socket进行通信了，什么是socket呢？我们经常把socket翻译为套接字，socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。 https://s1.ax1x.com/2020/04/16/JAKKYR.jpg socket起源于UNIX，在Unix一切皆文件哲学的思想下，socket是一种”打开—读/写—关闭”模式的实现，服务器和客户端各自维护一个”文件”，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。 socket通信流程socket是”打开—读/写—关闭”模式的实现，以使用TCP协议通讯的socket为例，其交互流程大概是这样子的 服务器根据地址类型（ipv4,ipv6）、socket类型、协议创建socket int socket(int domain, int type, int protocol); 服务器为socket绑定ip地址和端口号 服务器socket监听端口号请求，随时准备接收客户端发来的连接，这时候服务器的socket并没有被打开 客户端创建socket 客户端打开socket，根据服务器ip地址和端口号试图连接服务器socket 服务器socket接收到客户端socket请求，被动打开，开始接收客户端请求，直到客户端返回连接信息。这时候socket进入阻塞状态，所谓阻塞即accept()方法一直到客户端返回连接信息后才返回，开始接收下一个客户端谅解请求 客户端连接成功，向服务器发送连接状态信息 服务器accept方法返回，连接成功 客户端向socket写入信息 服务器读取信息 客户端关闭 服务器端关闭 服务器socket与客户端socket建立连接的部分其实就是大名鼎鼎的三次握手 socket编程API 前面提到socket是”打开—读/写—关闭”模式的实现，简单了解一下socket提供了哪些API供应用程序使用，还是以TCP协议为例，看看Unix下的socket API，其它语言都很类似（PHP甚至名字都几乎一样），这里我就简单解释一下方法作用和参数，具体使用有兴趣同学可以看看博客参考中的链接或者上网搜索 socket()：创建套接字。 1int socket(int domain, int type, int protocol); 根据指定的地址族、数据类型和协议来分配一个socket的描述字及其所用的资源。 domain:协议族，常用的有AF_INET、AF_INET6、AF_LOCAL、AF_ROUTE其中AF_INET代表使用ipv4地址 type:socket类型，常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等 protocol:协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等 bind()：指定本地地址。一个套接字用socket()创建后，它其实还没有与任何特定的本地或目的地址相关联。在很多情况下，应用程序并不关心它们使用的本地地址，这时就可以不用调用bind指定本地的地址，而由协议软件为它们选择一个。但是，在某个知名端口（Well-known Port）上操作的服务器进程必须要对系统指定本地端口。所以一旦创建了一个套接字，服务器就必须使用bind()系统调用为套接字建立一个本地地址。 1int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 把一个地址族中的特定地址赋给socket sockfd:socket描述字，也就是socket引用 addr:要绑定给sockfd的协议地址 addrlen:地址的长度 通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。 listen()：设置等待连接状态。对于一个服务器的程序，当申请到套接字，并调用bind()与本地地址绑定后，就应该等待某个客户机的程序来要求连接。listen()就是把一个套接字设置为这种状态的函数。同时也可以设置允许的最大连接数 1int listen(int sockfd, int backlog); 监听socket sockfd:要监听的socket描述字 backlog:相应socket可以排队的最大连接个数 connect()：将套接字连接到目的地址。初始创建的套接字并未与任何外地目的地址关联。客户机可以调用connect()为套接字绑定一个永久的目的地址，将它置于已连接状态。对数据流方式的套接字，必须在传输数据前，调用connect()构造一个与目的地的TCP连接，并在不能构造连接时返回一个差错代码。如果是数据报方式，则不是必须在传输数据前调用connect。如果调用了connect()，也并不像数据流方式那样发送请求建连的报文，而是只在本地存储目的地址，以后该socket上发送的所有数据都送往这个地址，程序员就可以免去为每一次发送数据都指定目的地址的麻烦。 1int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 连接某个socket sockfd:客户端的socket描述字 addr:服务器的socket地址 addrlen:socket地址的长度 accept()：接受连接请求。服务器进程使用系统调用socket，bind和listen创建一个套接字，将它绑定到知名的端口，并指定连接请求的队列长度。然后，服务器调用accept进入等待状态，直到到达一个连接请求。 1int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); TCP服务器监听到客户端请求之后，调用accept()函数取接收请求 sockfd:服务器的socket描述字 addr:客户端的socket地址 addrlen:socket地址的长度 send()/recv()或write（）/read()：发送和接收数据 。在数据流方式中，一个连接建立以后，或者在数据报方式下，调用了connect()进行了套接字与目的地址的绑定后，就可以调用send()和reev()函数进行数据传输。 1ssize_t read(int fd, void *buf, size_t count); 读取socket内容 fd:socket描述字 buf：缓冲区 count：缓冲区长度 1ssize_t write(int fd, const void *buf, size_t count); 向socket写入内容，其实就是发送内容 fd:socket描述字 buf：缓冲区 count：缓冲区长度 close()：关闭套接字。 1int close(int fd); socket标记为以关闭 ，使相应socket描述字的引用计数-1，当引用计数为0的时候，触发TCP客户端向服务器发送终止连接请求。 二、 Tinyhttp源码剖析1. 简介tinyhttpd是使用c语言开发的超轻量级http服务器，通过代码流程可以了解http服务器的基本处理流程，并且涉及了网络套接字，线程，父子进程，管道等等知识点； 2. 流程分析(1) 服务器启动，等待客户端请求到来； (2) 客户端请求到来，创建新线程处理该请求； (3) 读取httpHeader中的method，截取url，其中GET方法需要记录url问号之后的参数串; (4) 根据url构造完整路径，如果是/结尾，则指定为该目录下的index.html; (5) 获取文件信息，如果找不到文件，返回404，找到文件则判断文件权限； (6) 如果是GET请求并且没有参数，或者文件不可执行，则直接将文件内容构造http信息返回给客户端； (7) 如果是GET带参数，POST，文件可执行，则执行CGI； (8) GET请求略过httpHeader，POST方法需要记录httpHeader中的Content-Length:xx； (9) 创建管道用于父子进程通信，fork产生子进程； (10) 子进程设置环境变量，将标准输入和输出与管道相连，并且通过exec执行CGI； (11) 如果是POST，父进程将读到post内容发送给子进程，并且接收子进程的输出，输出给客户端； 3. 每个函数的作用123456789101112131415161718192021222324// accept_request: 处理从套接字上监听到的一个 HTTP 请求，在这里可以很大一部分地体现服务器处理请求流程。void accept_request(void *);// bad_request: 返回给客户端这是个错误请求，HTTP 状态吗 400 BAD REQUEST.void bad_request(int);// cat: 读取服务器上某个文件写到 socket 套接字。void cat(int, FILE *);// cannot_execute: 主要处理发生在执行 cgi 程序时出现的错误。void cannot_execute(int);// error_die: 把错误信息写到 perror 并退出。void error_die(const char *);// execute_cgi: 运行 cgi 程序的处理，也是个主要函数。void execute_cgi(int, const char *, const char *, const char *);// get_line: 读取套接字的一行，把回车换行等情况都统一为换行符结束int get_line(int, char *, int);// headers: 把 HTTP 响应的头部写到套接字void headers(int, const char *);// not_found: 主要处理找不到请求的文件时的情况。 void not_found(int);// sever_file: 调用 cat 把服务器文件返回给浏览器。void serve_file(int, const char *);// startup: 初始化 httpd 服务，包括建立套接字，绑定端口，进行监听等。int startup(u_short *);//unimplemented: 返回给浏览器表明收到的 HTTP 请求所用的 method 不被支持。void unimplemented(int); 建议源码阅读顺序： main -&gt; startup -&gt; accept_request -&gt; execute_cgi, 通晓主要工作流程后再仔细把每个函数的源码看一看。 4. 带注释的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677#include &lt;stdio.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/types.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;ctype.h&gt;#include &lt;strings.h&gt;#include &lt;string.h&gt;#include &lt;sys/stat.h&gt;#include &lt;pthread.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#define ISspace(x) isspace((int)(x))#define SERVER_STRING \"Server: jdbhttpd/0.1.0\\r\\n\"#define STDIN 0#define STDOUT 1#define STDERR 2// accept_request: 处理从套接字上监听到的一个 HTTP 请求，在这里可以很大一部分地体现服务器处理请求流程。void accept_request(void *);// bad_request: 返回给客户端这是个错误请求，HTTP 状态吗 400 BAD REQUEST.void bad_request(int);// cat: 读取服务器上某个文件写到 socket 套接字。void cat(int, FILE *);// cannot_execute: 主要处理发生在执行 cgi 程序时出现的错误。void cannot_execute(int);// error_die: 把错误信息写到 perror 并退出。void error_die(const char *);// execute_cgi: 运行 cgi 程序的处理，也是个主要函数。void execute_cgi(int, const char *, const char *, const char *);// get_line: 读取套接字的一行，把回车换行等情况都统一为换行符结束int get_line(int, char *, int);// headers: 把 HTTP 响应的头部写到套接字void headers(int, const char *);// not_found: 主要处理找不到请求的文件时的情况。 void not_found(int);// sever_file: 调用 cat 把服务器文件返回给浏览器。void serve_file(int, const char *);// startup: 初始化 httpd 服务，包括建立套接字，绑定端口，进行监听等。int startup(u_short *);//unimplemented: 返回给浏览器表明收到的 HTTP 请求所用的 method 不被支持。void unimplemented(int);/**********************************************************************//* 对于每一个http请求，都会创建一个线程，线程去执行这个函数去处理请求 * 参数: 连接到客户端的套接字*//**********************************************************************/void accept_request(int client)&#123; char buf[1024]; // 读取行数据时的缓冲区 int numchars; // 读取了多少字符 char method[255]; // 存储HTTP请求方法名称（字符串） char url[255]; // 存储url char path[512]; size_t i, j; //size_t在cstddef头文件中，和int应该具有相同的长度 struct stat st; int cgi = 0; /* becomes true if server decides this is a CGI * program */ char *query_string = NULL;//读http 请求的第一行数据（request line），把请求方法存进 method 中// 一个HTTP请求报文由请求行（requestline）、请求头部（header）、空行和请求数据4个部分组成// 请求行由请求方法字段（get或post）、URL字段和HTTP协议版本字段3个字段组成// 它们用空格分隔。如：GET /index.html HTTP/1.1。// 解析请求行，把方法字段保存在method变量中。// 读取HTTP头第一行：GET/index.php HTTP 1.1 numchars = get_line(client, buf, sizeof(buf)); //get_line函数：读取套接字的一行，把回车换行等情况都统一为换行符结束。 i = 0; j = 0; // 把客户端的请求方法存到method数组 while (!ISspace(buf[j]) &amp;&amp; (i &lt; sizeof(method) - 1)) &#123; method[i] = buf[j]; i++; j++; &#125; method[i] = '\\0'; //如果请求的方法不是 GET 或 POST 任意一个的话就直接发送 response 告诉客户端没实现该方法 /*头文件：#include &lt;string.h&gt;定义函数：int strcasecmp (const char *s1, const char *s2);函数说明：strcasecmp()用来比较参数s1 和s2 字符串，比较时会自动忽略大小写的差异。返回值：若参数s1 和s2 字符串相同则返回0。s1 长度大于s2 长度则返回大于0 的值，s1 长度若小于s2 长度则返回小于0 的值。*/ if (strcasecmp(method, \"GET\") &amp;&amp; strcasecmp(method, \"POST\")) &#123; unimplemented(client); //unimplemented函数：返回给浏览器表明收到的HTTP请求所用的method不被支持。 return; &#125; //如果是 POST 方法就将 cgi 标志变量置一(true) if (strcasecmp(method, \"POST\") == 0) cgi = 1;// 解析并保存请求的URL（如有问号，也包括问号及之后的内容） i = 0; //跳过所有的空白字符(空格) while (ISspace(buf[j]) &amp;&amp; (j &lt; sizeof(buf))) j++; //然后从缓冲区把 URL 读出来放到 url 数组中 while (!ISspace(buf[j]) &amp;&amp; (i &lt; sizeof(url) - 1) &amp;&amp; (j &lt; sizeof(buf))) &#123; url[i] = buf[j]; i++; j++; &#125; url[i] = '\\0';// 如果这个请求是一个 GET 方法的话// 如果是get方法，请求参数和对应的值附加在URL后面，利用一个问号（“？”）代表URL的结// 尾与请求参数的开始，传递参数长度受限制。如index.jsp?10023，其中10023就是要传递// 的参数。这段代码将参数保存在query_string中。 if (strcasecmp(method, \"GET\") == 0) &#123; //用一个指针指向 url query_string = url; //去遍历这个 url，跳过字符 ？前面的所有字符，如果遍历完毕也没找到字符 ？则退出循环 while ((*query_string != '?') &amp;&amp; (*query_string != '\\0')) query_string++; //退出循环后检查当前的字符是 ？还是字符串(url)的结尾 if (*query_string == '?') &#123; //如果是 ？ 的话，证明这个请求需要调用 cgi，将 cgi 标志变量置一(true) cgi = 1; //从字符 ？ 处把字符串 url 给分隔会两份 *query_string = '\\0'; //使指针指向字符 ？后面的那个字符 query_string++; &#125; &#125;// 保存有效的url地址并加上请求地址的主页索引。默认的根目录是htdocs下// 这里是做以下路径拼接，因为url字符串以'/'开头，所以不用拼接新的分割符// 格式化url到path数组，html文件都在htdocs中//将前面分隔两份的前面那份字符串，拼接在字符串htdocs的后面之后就输出存储到数组 path 中。相当于现在 path 中存储着一个字符串 sprintf(path, \"htdocs%s\", url); //如果 path 数组中的这个字符串的最后一个字符是以字符 / 结尾的话，就拼接上一个\"index.html\"的字符串。即默认访问index.html if (path[strlen(path) - 1] == '/') strcat(path, \"index.html\"); // 访问请求的文件，如果文件不存在直接返回，如果存在就调用CGI程序来处理 /*头文件: #include &lt;sys/stat.h&gt; 函数定义: int stat(const char *file_name, struct stat *buf); 函数说明: 通过文件名filename获取文件信息，并保存在buf所指的结构体stat中 返回值: 执行成功则返回0，失败返回-1，错误代码存于errno（需要include &lt;errno.h&gt;）*/ if (stat(path, &amp;st) == -1) &#123; //如果不存在，那把这次 http 的请求后续的内容(head 和 body)全部读完并忽略 while ((numchars &gt; 0) &amp;&amp; strcmp(\"\\n\", buf)) /* read &amp; discard headers */ numchars = get_line(client, buf, sizeof(buf)); //然后返回一个找不到文件的 response 给客户端 not_found(client); &#125; else &#123;// 如果文件存在但却是个目录，则继续拼接路径，默认访问这个目录下的index.html //文件存在，那去跟常量S_IFMT相与，相与之后的值可以用来判断该文件是什么类型的 //S_IFMT参读《TLPI》P281，与下面的三个常量一样是包含在&lt;sys/stat.h&gt; if ((st.st_mode &amp; S_IFMT) == S_IFDIR) //如果这个文件是个目录，那就需要再在 path 后面拼接一个\"/index.html\"的字符串 strcat(path, \"/index.html\"); //如果这个文件是一个可执行文件，不论是属于用户/组/其他这三者类型的，就将 cgi 标志变量置一 //在调用CGI之前有一段是对用户权限的判断，对应含义如下 //S_IXUSR：用户可以执行 //S_IXGRP：组可以执行 //S_IXOTH：其它人可以执行 if ((st.st_mode &amp; S_IXUSR) || (st.st_mode &amp; S_IXGRP) || (st.st_mode &amp; S_IXOTH) ) cgi = 1; if (!cgi) //如果不需要 cgi 机制的话，直接把服务器文件返回 serve_file(client, path); else //如果需要则调用 execute_cgi(client, path, method, query_string); &#125;// 断开与客户端的连接（HTTP特点：无连接） close(client);&#125;/**********************************************************************//* bad_request函数：返回给客户端这是个错误请求，HTTP状态码400 Bad Request。 * 参数: 客户端套接字*//**********************************************************************/void bad_request(int client)&#123; char buf[1024];/*函数原型：int send( SOCKET s,char *buf,int len,int flags );功能：不论是客户还是服务器应用程序都用send函数来向TCP连接的另一端发送数据。客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答。参数一：指定发送端套接字描述符；参数二：存放应用程序要发送数据的缓冲区；参数三：实际要发送的数据的字节数；参数四：一般置为0。*/ sprintf(buf, \"HTTP/1.0 400 BAD REQUEST\\r\\n\"); send(client, buf, sizeof(buf), 0); sprintf(buf, \"Content-type: text/html\\r\\n\"); send(client, buf, sizeof(buf), 0); sprintf(buf, \"\\r\\n\"); send(client, buf, sizeof(buf), 0); sprintf(buf, \"&lt;P&gt;Your browser sent a bad request, \"); send(client, buf, sizeof(buf), 0); sprintf(buf, \"such as a POST without a Content-Length.\\r\\n\"); send(client, buf, sizeof(buf), 0);&#125;/**********************************************************************//* Put the entire contents of a file out on a socket. This function * is named after the UNIX \"cat\" command, because it might have been * easier just to do something like pipe, fork, and exec(\"cat\"). * Parameters: the client socket descriptor * FILE pointer for the file to cat *//**********************************************************************/// cat函数：读取服务器上某个文件写到socket套接字。void cat(int client, FILE *resource)&#123; char buf[1024]; //第一次从文件文件描述符中读取指定内容 fgets(buf, sizeof(buf), resource); //循环读取并发送文件内容 while (!feof(resource)) &#123; send(client, buf, strlen(buf), 0); fgets(buf, sizeof(buf), resource); &#125;&#125;/**********************************************************************//* Inform the client that a CGI script could not be executed. * Parameter: the client socket descriptor. *//**********************************************************************/// cannot_execute函数：处理发生在执行cgi程序时出现的错误void cannot_execute(int client)&#123; char buf[1024]; sprintf(buf, \"HTTP/1.0 500 Internal Server Error\\r\\n\");//500 Internal Server Error //服务器发生不可预期的错误 send(client, buf, strlen(buf), 0); sprintf(buf, \"Content-type: text/html\\r\\n\"); send(client, buf, strlen(buf), 0); sprintf(buf, \"\\r\\n\"); send(client, buf, strlen(buf), 0); sprintf(buf, \"&lt;P&gt;Error prohibited CGI execution.\\r\\n\"); send(client, buf, strlen(buf), 0);&#125;/**********************************************************************//* Print out an error message with perror() (for system errors; based * on value of errno, which indicates system call errors) and exit the * program indicating an error. *//**********************************************************************/// error_die函数：把错误信息写到perror并退出。void error_die(const char *sc)&#123; //打印错误信息并退出 //包含于&lt;stdio.h&gt;,基于当前的 errno 值，在标准错误上产生一条错误消息。参考《TLPI》P49 perror(sc); exit(1);&#125;/**********************************************************************//* 执行CGI脚本 * 参数: client socket descriptor * path to the CGI script *//**********************************************************************///对于带有参数的get请求和 post请求，这两类并不能直接返回一个静态的html文件，需要cgi//cgi是common gateway interface（公共网关接口）的简称//谈一下我对cgi的理解，就是对于不能直接返回静态页面的请求，这些请求一定是需要在服务器上面运行一段代码，然后返回一个结果//具体一点的谈：//比如一个 get请求 /index?uid=100,它可能对应的场景是返回id=100用户的页面，这显然不是一个静态的页面，需要动态的生成，然后服务器把这个id=100的参数拿到，去执行本地的一个 xxx.cgi 文件，//执行这个文件的时候，参数是id=100，然后将执行这个文件的输出返回给浏览器 可以参考 ： http://www.runoob.com/python/python-cgi.html//cgi理解参考：https://www.zhihu.com/question/19998865//注意：client是一个文件剧本，在accept_request函数里面，只读了第一行，在execute_cgi函数里面，把剩下的读完void execute_cgi(int client, const char *path, const char *method, const char *query_string)&#123; char buf[1024]; int cgi_output[2]; int cgi_input[2]; //pid_t 类型在 Linux 环境编程中用于定义进程 ID，需要引入头文件&lt;sys/types.h&gt; //pid_t 等于 int pid_t pid; int status; int i; char c; int numchars = 1; int content_length = -1; //往 buf 中填东西以保证能进入下面的 while buf[0] = 'A'; buf[1] = '\\0'; //如果是 http 请求是 GET 方法的话读取并忽略请求剩下的内容 if (strcasecmp(method, \"GET\") == 0) while ((numchars &gt; 0) &amp;&amp; strcmp(\"\\n\", buf)) /* read &amp; discard headers */ numchars = get_line(client, buf, sizeof(buf)); else /* POST */ &#123; //只有 POST 方法才继续读内容 numchars = get_line(client, buf, sizeof(buf)); //这个循环的目的是读出指示 body 长度大小的参数，并记录 body 的长度大小（content_length）。其余的 header 里面的参数一律忽略 //注意这里只读完 header 的内容，body 的内容没有读 while ((numchars &gt; 0) &amp;&amp; strcmp(\"\\n\", buf)) &#123; buf[15] = '\\0'; //// 使用\\0进行分割 if (strcasecmp(buf, \"Content-Length:\") == 0) content_length = atoi(&amp;(buf[16])); //记录 body 的长度大小 atoi(const char *nptr):把字符串转换成整型数 numchars = get_line(client, buf, sizeof(buf)); &#125; //如果 http 请求的 header 没有指示 body 长度大小的参数，则报错返回 if (content_length == -1) &#123; bad_request(client); return; &#125; &#125;//发送http200头 ，200 OK表示客户端请求成功 sprintf(buf, \"HTTP/1.0 200 OK\\r\\n\"); send(client, buf, strlen(buf), 0); //下面这里创建两个管道，用于两个进程间通信 if (pipe(cgi_output) &lt; 0) &#123;//输出管道 cannot_execute(client);// 错误处理 return; &#125; if (pipe(cgi_input) &lt; 0) &#123;//输入管道 cannot_execute(client); return; &#125; //创建一个子进程 if ( (pid = fork()) &lt; 0 ) &#123;// fork系统调用用于创建一个新进程，称为子进程，它与进程（称为系统调用fork的进程）同时运行，此进程称为父进程。 cannot_execute(client); return; &#125; //子进程用来执行 cgi 脚本 if (pid == 0) /* child: CGI script */ &#123; char meth_env[255]; char query_env[255]; char length_env[255]; //dup2()包含&lt;unistd.h&gt;中，参读《TLPI》P97 //将子进程的输出由标准输出重定向到 cgi_ouput 的管道写端上 dup2(cgi_output[1], 1); //将子进程的输出由标准输入重定向到 cgi_input 的管道读端上 dup2(cgi_input[0], 0); close(cgi_output[0]);//关闭 cgi_ouput 管道的读端 close(cgi_input[1]); //关闭cgi_input 管道的写端 // 服务器设置环境变量，即request_method的环境变量 sprintf(meth_env, \"REQUEST_METHOD=%s\", method); //putenv()包含于&lt;stdlib.h&gt;中，参读《TLPI》P128 //将这个环境变量加进子进程的运行环境中 putenv(meth_env); //根据http 请求的不同方法，构造并存储不同的环境变量 ////如果是GET方式设置请求参数环境变量 if (strcasecmp(method, \"GET\") == 0) &#123; sprintf(query_env, \"QUERY_STRING=%s\", query_string); putenv(query_env); &#125; else &#123; //如果是POST方式设置内容长度环境变量 sprintf(length_env, \"CONTENT_LENGTH=%d\", content_length); putenv(length_env); &#125; //execl()包含于&lt;unistd.h&gt;中，参读《TLPI》P567 //执行 cgi 脚本 execl(path, path, NULL); exit(0); &#125; else &#123; /* parent */ //父进程 close(cgi_output[1]);//父进程则关闭了 cgi_output管道的写端 close(cgi_input[0]);//父进程则关闭了cgi_input 管道的读端 //如果是 POST 方法的话就继续读 body 的内容，并写到 cgi_input 管道里让子进程去读 if (strcasecmp(method, \"POST\") == 0) for (i = 0; i &lt; content_length; i++) &#123; recv(client, &amp;c, 1, 0); write(cgi_input[1], &amp;c, 1); &#125; //然后从 cgi_output 管道中读子进程的输出，并发送到客户端去 while (read(cgi_output[0], &amp;c, 1) &gt; 0) send(client, &amp;c, 1, 0); //关闭管道 close(cgi_output[0]); close(cgi_input[1]); //等待子进程的退出 waitpid(pid, &amp;status, 0); &#125;&#125;/**********************************************************************//* Get a line from a socket, whether the line ends in a newline, * carriage return, or a CRLF combination. Terminates the string read * with a null character. If no newline indicator is found before the * end of the buffer, the string is terminated with a null. If any of * the above three line terminators is read, the last character of the * string will be a linefeed and the string will be terminated with a * null character. * Parameters: the socket descriptor * the buffer to save the data in * the size of the buffer * Returns: the number of bytes stored (excluding null) *//**********************************************************************/int get_line(int sock, char *buf, int size)&#123; int i = 0; char c = '\\0'; int n;//接收\\n结束的一行数据或接收满缓冲区 while ((i &lt; size - 1) &amp;&amp; (c != '\\n')) &#123; //recv()包含于&lt;sys/socket.h&gt;,参读《TLPI》P1259, //读一个字节的数据存放在 c 中 n = recv(sock, &amp;c, 1, 0); /* DEBUG printf(\"%02X\\n\", c); */ if (n &gt; 0) &#123; //如果接收到了\\r符号（回车符） if (c == '\\r') &#123; //将下一个字字符预取出来，注意MSG_PEEK本地接收窗口不滑动，下次读取仍然可以读取到该字符 n = recv(sock, &amp;c, 1, MSG_PEEK); /* DEBUG printf(\"%02X\\n\", c); */ //如果下一个字符是\\n的话，那么接收这个字符 if ((n &gt; 0) &amp;&amp; (c == '\\n')) recv(sock, &amp;c, 1, 0); //不是\\n的话，那么将\\r替换成\\n else c = '\\n'; &#125; //字符存入buf，继续读取 buf[i] = c; i++; &#125; else c = '\\n'; &#125; //设置buf字符串结束符 buf[i] = '\\0'; return(i);&#125;/**********************************************************************//* Return the informational HTTP headers about a file. *//* Parameters: the socket to print the headers on * the name of the file *//**********************************************************************/// headers函数：把HTTP响应的头部写到套接字void headers(int client, const char *filename)&#123; char buf[1024]; (void)filename; /* could use filename to determine file type *///发送http头 http码 服务器信息 内容类型等头部信息 strcpy(buf, \"HTTP/1.0 200 OK\\r\\n\"); send(client, buf, strlen(buf), 0); strcpy(buf, SERVER_STRING); //服务器信息 send(client, buf, strlen(buf), 0); sprintf(buf, \"Content-Type: text/html\\r\\n\"); send(client, buf, strlen(buf), 0); strcpy(buf, \"\\r\\n\"); //到这里就结束了，没有body send(client, buf, strlen(buf), 0);&#125;/**********************************************************************//* Give a client a 404 not found status message. *//**********************************************************************/// not_found函数：处理找不到请求的文件时的情况。void not_found(int client)&#123; char buf[1024]; //发送http头 http码 服务器信息 内容类型等头部信息 html提示信息 sprintf(buf, \"HTTP/1.0 404 NOT FOUND\\r\\n\");//404 Not Found //请求资源不存在，eg：输入了错误的URL send(client, buf, strlen(buf), 0); sprintf(buf, SERVER_STRING); send(client, buf, strlen(buf), 0); sprintf(buf, \"Content-Type: text/html\\r\\n\"); send(client, buf, strlen(buf), 0); sprintf(buf, \"\\r\\n\"); send(client, buf, strlen(buf), 0); //以下为html提示信息 sprintf(buf, \"&lt;HTML&gt;&lt;TITLE&gt;Not Found&lt;/TITLE&gt;\\r\\n\"); send(client, buf, strlen(buf), 0); sprintf(buf, \"&lt;BODY&gt;&lt;P&gt;The server could not fulfill\\r\\n\"); send(client, buf, strlen(buf), 0); sprintf(buf, \"your request because the resource specified\\r\\n\"); send(client, buf, strlen(buf), 0); sprintf(buf, \"is unavailable or nonexistent.\\r\\n\"); send(client, buf, strlen(buf), 0); sprintf(buf, \"&lt;/BODY&gt;&lt;/HTML&gt;\\r\\n\"); send(client, buf, strlen(buf), 0);&#125;/**********************************************************************//* Send a regular file to the client. Use headers, and report * errors to client if they occur. * Parameters: a pointer to a file structure produced from the socket * file descriptor * the name of the file to serve *//**********************************************************************/// serve_file函数：调用cat函数把服务器文件返回给浏览器void serve_file(int client, const char *filename)&#123; FILE *resource = NULL; int numchars = 1; char buf[1024]; //确保 buf 里面有东西，能进入下面的 while 循环 buf[0] = 'A'; buf[1] = '\\0'; //循环作用是读取并忽略掉这个 http 请求后面的所有内容 while ((numchars &gt; 0) &amp;&amp; strcmp(\"\\n\", buf)) /* read &amp; discard headers */ numchars = get_line(client, buf, sizeof(buf)); //打开这个传进来的这个路径所指的文件 resource = fopen(filename, \"r\"); if (resource == NULL) // //打开失败，发送404 not_found(client); else &#123; //打开成功后，将这个文件的基本信息封装成 response 的头部(header)并返回 headers(client, filename); //接着把这个文件的内容读出来作为 response 的 body 发送到客户端 cat(client, resource); &#125; fclose(resource);&#125;/**********************************************************************//*该函数启动监听指定端口上的web连接的过程，包括建立套接字，绑定端口，进行监听等。 如果端口为0，则动态分配端口并修改原始端口变量以反映实际端口。 * 参数: 指向包含要连接的端口的变量的指针 * 返回: 套接字 *//**********************************************************************/int startup(u_short *port)&#123; int httpd = 0; //sockaddr_in 是 IPV4的套接字地址结构。定义在&lt;netinet/in.h&gt;,参读《TLPI》P1202 struct sockaddr_in name; //创建一个tcp socket，建立socket连接 //socket()用于创建一个用于 socket 的描述符，函数包含于&lt;sys/socket.h&gt; httpd = socket(PF_INET, SOCK_STREAM, 0); if (httpd == -1) error_die(\"socket\"); // 填充结构体//void *memset(void *s, int ch, size_t n);//函数解释：将s中当前位置后面的n个字节 （typedef unsigned int size_t ）用 ch 替换并返回 s 。//memset：作用是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法 [1]*/memset(&amp;name, 0, sizeof(name)); name.sin_family = AF_INET; //htons()，ntohs() 和 htonl()包含于&lt;arpa/inet.h&gt;, 参读《TLPI》P1199 //将*port 转换成以网络字节序表示的16位整数 name.sin_port = htons(*port); //INADDR_ANY是一个 IPV4通配地址的常量，包含于&lt;netinet/in.h&gt; //大多实现都将其定义成了0.0.0.0 参读《TLPI》P1187 name.sin_addr.s_addr = htonl(INADDR_ANY); // 绑定到本地地址port指定端口 //bind()用于绑定地址与 socket。参读《TLPI》P1153 //如果传进去的sockaddr结构中的 sin_port 指定为0，这时系统会选择一个临时的端口号 if (bind(httpd, (struct sockaddr *)&amp;name, sizeof(name)) &lt; 0) error_die(\"bind\"); //如果当前指定的端口是0，则动态随机分配一个端口//如果调用 bind 后端口号仍然是0，则手动调用getsockname()获取端口号 if (*port == 0) /* if dynamically allocating a port */ &#123; int namelen = sizeof(name); //getsockname()包含于&lt;sys/socker.h&gt;中，参读《TLPI》P1263 //调用getsockname()获取系统给 httpd 这个 socket 随机分配的端口号 if (getsockname(httpd, (struct sockaddr *)&amp;name, &amp;namelen) == -1) error_die(\"getsockname\"); *port = ntohs(name.sin_port); &#125; // 开始监听 if (listen(httpd, 5) &lt; 0) error_die(\"listen\"); // 返回socket id return(httpd);&#125;/**********************************************************************//* Inform the client that the requested web method has not been * implemented. * Parameter: the client socket *//**********************************************************************/// unimplemented函数：返回给浏览器表明收到的HTTP请求所用的method不被支持。void unimplemented(int client)&#123; char buf[1024];//发送未实现的请求方法和提示消息给客户端 sprintf(buf, \"HTTP/1.0 501 Method Not Implemented\\r\\n\"); send(client, buf, strlen(buf), 0); sprintf(buf, SERVER_STRING); send(client, buf, strlen(buf), 0); sprintf(buf, \"Content-Type: text/html\\r\\n\"); send(client, buf, strlen(buf), 0); sprintf(buf, \"\\r\\n\"); send(client, buf, strlen(buf), 0); sprintf(buf, \"&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Method Not Implemented\\r\\n\"); send(client, buf, strlen(buf), 0); sprintf(buf, \"&lt;/TITLE&gt;&lt;/HEAD&gt;\\r\\n\"); send(client, buf, strlen(buf), 0); sprintf(buf, \"&lt;BODY&gt;&lt;P&gt;HTTP request method not supported.\\r\\n\"); send(client, buf, strlen(buf), 0); sprintf(buf, \"&lt;/BODY&gt;&lt;/HTML&gt;\\r\\n\"); send(client, buf, strlen(buf), 0);&#125;/**********************************************************************/int main(void)&#123; int server_sock = -1; //服务器套接字 u_short port = 0; //监听端口 int client_sock = -1; //客户端套接字 //sockaddr_in 是 IPV4的套接字地址结构。定义在&lt;netinet/in.h&gt;,参读《TLPI》P1202 struct sockaddr_in client_name; //socklen_t ：linux头文件#include &lt;sys/socket.h&gt; //详细定义：typedef int socklen_t; socklen_t client_name_len = sizeof(client_name); //pthread_t：typedef unsigned long int pthread_t; //用途：pthread_t用于声明线程ID。 pthread_t newthread;//建立一个监听套接字，在对应的端口建立httpd服务 server_sock = startup(&amp;port); printf(\"httpd running on port %d\\n\", port);// 进入循环，服务器通过调用accept等待客户端的连接，Accept会以阻塞的方式运行，直到// 有客户端连接才会返回。连接成功后，服务器启动一个新的线程来处理客户端的请求，处理// 完成后，重新等待新的客户端请求。 while (1) &#123; //Accept会以阻塞的方式运行，直到有客户端连接才会返回 client_sock = accept(server_sock, (struct sockaddr *)&amp;client_name, &amp;client_name_len); if (client_sock == -1) error_die(\"accept\"); //对于一个socket连接(即一个http请求)，创建一个线程去处理 if (pthread_create(&amp;newthread , NULL, accept_request, client_sock) != 0) perror(\"pthread_create\"); &#125;// 出现意外退出的时候，关闭socket close(server_sock); return(0);&#125; 管程示意图： 三、 思考总结 对于一个http请求，如果从请求里面解析到关键的字段信息，比如 http method，是get，post，put，delete，还是head? url是什么？ 如果是post类型的请求，post的参数是在http请求的正文里面的，那么怎么读取出来他们？他们的长度是如何确定的？ 判断http 请求header的每一行的标志是 ：\\r\\n 判断http请求header和请求正文的标志是：两个\\r\\n （如上图） 对于，一个post请求，请求的正文里面是post的请求数据，header里面的content-length指明了post请求的数据的长度。 对于带有参数的get方法，和post方法，你的服务器如何去处理？ 带有参数的get请求，和post请求，服务器没有办法简单的返回一个静态的文件，服务器需要在服务器端将相应的页面“计算”出来，然后返回给浏览器。 假如，浏览器发送了一个请求 /index?id=100，请求id=100的人的主页 那么，服务器需要“计算”出来id=100的这个人的主页的的页面。这个就需要cgi来帮忙了，cgi可以理解为在服务器端可以执行的小脚本。服务器收到这个请求之后，执行index.cgi （这个文件是提前写好了，专门来处理这样的请求) ，服务器执行index.cgi ，参数是id=100，然后“计算”出网页的数据，返回给浏览器。","categories":[{"name":"项目实战","slug":"项目实战","permalink":"http://yoursite.com/categories/项目实战/"}],"tags":[{"name":"TinyHttp","slug":"TinyHttp","permalink":"http://yoursite.com/tags/TinyHttp/"}]},{"title":"进程的互斥、同步、通信","slug":"进程、线程的同步与通信","date":"2020-03-15T01:43:14.000Z","updated":"2020-04-16T09:32:52.656Z","comments":true,"path":"2020/03/15/进程、线程的同步与通信/","link":"","permalink":"http://yoursite.com/2020/03/15/进程、线程的同步与通信/","excerpt":"","text":"进程的互斥、同步、通信进程的互斥、同步、通信都是基于竞争和协作关系而存在的。 为了解决进程间竞争关系（间接制约关系）而引入进程互斥； 为了解决进程间松散的协作关系( 直接制约关系)而引入进程同步； 为了解决进程间紧密的协作关系而引入进程通信。 进程的互斥资源竞争出现了两个控制问题： 一个是死锁 （deadlock ）问题，一组进程如果都获得了部分资源，还想要得到其他进程所占有的资源，最终所有的进程将陷入死锁。 另一个是饥饿（starvation ）问题，这是指这样一种情况：一个进程由于其他进程总是优先于它而被无限期拖延。 进程的互斥（mutual exclusion ）是解决进程间竞争关系( 间接制约关系) 的手段。 进程互斥指若干个进程要使用同一共享资源时，任何时刻最多允许一个进程去使用，其他要使用该资源的进程必须等待，直到占有资源的进程释放该资源。 进程的同步进程的同步（Synchronization）是解决进程间协作关系( 直接制约关系) 的手段。 进程间的同步是双方不知道对方名字的间接协作，例如，通过共享访问一个缓冲区进行松散式协作； 进程同步指两个以上进程基于某个条件来协调它们的活动。一个进程的执行依赖于另一个协作进程的消息或信号，当一个进程没有得到来自于另一个进程的消息或信号时则需等待，直到消息或信号到达才被唤醒。 进程互斥关系是一种特殊的进程同步关系，即逐次使用互斥共享资源，也是对进程使用资源次序上的一种协调。 进程的同步方法：（进程互斥关系是一种特殊的进程同步关系，所以也可用于进程的互斥） 信号量 互斥量 管程 进程的通信并发进程之间的交互必须满足两个基本要求：同步和通信。 进程竞争资源时要实施互斥，互斥是一种特殊的同步，实质上需要解决好进程同步问题，进程同步是一种进程通信，通过修改信号量，进程之间可建立起联系，相互协调运行和协同工作。但是信号量与PV操作只能传递信号，没有传递数据的能力。有些情况下进程之间交换的信息量虽很少，例如，仅仅交换某个状态信息，但很多情况下进程之间需要交换大批数据，例如，传送一批信息或整个文件，这可以通过一种新的通信机制来完成，进程之间互相交换信息的工作称之为进程通信IPC （InterProcess Communication）（主要是指大量数据的交换）。 进程的通信方式进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。 管道： 管道主要包括无名管道和命名管道:管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信 1.1.普通管道PIPE： 1)它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端 2)它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间） 3)它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。 1.2 命名管道FIFO： 1)FIFO可以在无关的进程之间交换数据 2)FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。 系统IPC： 2.1 消息队列 消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。 (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息； 特点： 1)消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。 2)消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。 3)消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。 2.2 信号量semaphore 信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。 特点： 1)信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。 2)信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。 3)每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。 4)支持信号量组。 2.3 信号signal 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。 signal，又简称为信号（软中断信号）用来通知进程发生了异步事件。 原理： 一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是进程间通信机制中唯一的异步通信机制，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。进程之间可以互相通过系统调用kill发送软中断信号。内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。信号机制除了基本通知功能外，还可以传递附加信息。 2.4 共享内存（Shared Memory） 它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等 特点： 1)共享内存是最快的一种IPC，因为进程是直接对内存进行存取 2)因为多个进程可以同时操作，所以需要进行同步 3)信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问 套接字SOCKET： socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。 线程的通信方式（查阅了很多资料，把同步方式和通信方式混为一谈，那这里也把这两种当做一回事吧） 临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问； 互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问 信号量Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。 事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作 信号量与互斥量的区别： 信号量：多线程同步使用的；一个线程完成某个动作后通过信号告诉别的线程，别的线程才可以执行某些动作； 互斥量：多线程互斥使用的；一个线程占用某个资源，那么别的线程就无法访问，直到该线程离开，其他线程才可以访问该资源 互斥锁的作用就是互斥，mutual exclusive，是用来保护临界区(critical section)的。所谓临界区就是代码的一个区间，如果两个线程同时执行就有可能出问题，所以需要互斥锁来保护。 信号量（semaphore）是一种更高级的同步机制，mutex可以说是semaphore在仅取值0/1时的特例。Semaphore可以有更多的取值空间，用来实现更加复杂的同步，而不单单是线程间互斥。 1、互斥量用于线程的互斥，信号量用于线程的同步： 互斥：指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排他性。但是互斥无法限制访问者对资源的访问顺序，所以访问是无序的； 同步：指在互斥的基础上（多数情况），通过其他机制实现访问者对资源的有序访问。大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况指可以允许多个访问者同时访问资源。 2、互斥量值只能是0/1，信号量值可以为非负整数： 一个互斥量只能用于一个资源的互斥访问不能实现多个资源的多线程互斥问题； 一个信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量时，也可以完成一个资源的互斥访问； 3、互斥量的加锁和解锁必须由同一线程分别对应使用；而信号量可以由一个线程释放，另外一个线程得到。","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"}]},{"title":"死锁 活锁 饥饿","slug":"死锁 活锁 饥饿","date":"2020-03-10T08:43:14.000Z","updated":"2020-04-16T09:45:38.884Z","comments":true,"path":"2020/03/10/死锁 活锁 饥饿/","link":"","permalink":"http://yoursite.com/2020/03/10/死锁 活锁 饥饿/","excerpt":"","text":"死锁 活锁 饥饿死锁（争来争去 谁也得不到）死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 死锁发生的条件 互斥条件：线程对资源的访问是排他性的，如果一个线程对占用了某资源，那么其他线程必须处于等待状态，直到资源被释放。 请求和保持条件：线程T1至少已经保持了一个资源R1占用,但又提出对另一个资源R2请求，而此时，资源R2被其他线程T2占用，于是该线程T1也必须等待，但又对自己保持的资源R1不释放。 不剥夺条件：线程已获得的资源，在未使用完之前，不能被其他线程剥夺，只能在使用完以后由自己释放。 环路等待条件：在死锁发生时，必然存在一个“进程-资源环形链”，即：{p0,p1,p2,…pn},进程p0（或线程）等待p1占用的资源，p1等待p2占用的资源，pn等待p0占用的资源。（最直观的理解是，p0等待p1占用的资源，而p1而在等待p0占用的资源，于是两个进程就相互等待） 活锁（让来让去 谁都不拥有）活锁：是指线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源。 关于“死锁与活锁”的比喻： 死锁：迎面开来的汽车A和汽车B过马路，汽车A得到了半条路的资源（满足死锁发生条件1：资源访问是排他性的，我占了路你就不能上来，除非你爬我头上去），汽车B占了汽车A的另外半条路的资源，A想过去必须请求另一半被B占用的道路（死锁发生条件2：必须整条车身的空间才能开过去，我已经占了一半，尼玛另一半的路被B占用了），B若想过去也必须等待A让路，A是辆兰博基尼，B是开奇瑞QQ的屌丝，A素质比较低开窗对B狂骂：快给老子让开，B很生气，你妈逼的，老子就不让（死锁发生条件3：在未使用完资源前，不能被其他线程剥夺），于是两者相互僵持一个都走不了（死锁发生条件4：环路等待条件），而且导致整条道上的后续车辆也走不了。 活锁：马路中间有条小桥，只能容纳一辆车经过，桥两头开来两辆车A和B，A比较礼貌，示意B先过，B也比较礼貌，示意A先过，结果两人一直谦让谁也过不去。 饥饿（排多久 都轮不到自己）饥饿：是指如果线程T1占用了资源R，线程T2又请求封锁R，于是T2等待。T3也请求资源R，当T1释放了R上的封锁后，系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后，系统又批准了T4的请求……，T2可能永远等待。 关于”饥饿“的比喻： 在“首堵”北京的某一天，天气阴沉，空气中充斥着雾霾和地沟油的味道，某个苦逼的临时工交警正在处理塞车，有两条道A和B上都堵满了车辆，其中A道堵的时间最长，B相对相对堵的时间较短，这时，前面道路已疏通，交警按照最佳分配原则，示意B道上车辆先过，B道路上过了一辆又一辆，A道上排队时间最长的确没法通过，只能等B道上没有车辆通过的时候再等交警发指令让A道依次通过，这也就是ReentrantLock显示锁里提供的不公平锁机制（当然了，ReentrantLock也提供了公平锁的机制，由用户根据具体的使用场景而决定到底使用哪种锁策略），不公平锁能够提高吞吐量但不可避免的会造成某些线程的饥饿。 参考：https://www.cnblogs.com/ktgu/p/3529143.html","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"}]},{"title":"Python学习笔记（二）","slug":"Python学习笔记-基本知识","date":"2020-03-06T02:43:14.000Z","updated":"2020-04-16T09:46:05.084Z","comments":true,"path":"2020/03/06/Python学习笔记-基本知识/","link":"","permalink":"http://yoursite.com/2020/03/06/Python学习笔记-基本知识/","excerpt":"","text":"输入输出print()*你需要确保每一行的第一个字符前面都没有任何空格或制表格 * print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 **end=&quot;&quot;：** print()函数可以接受多个字符串，用逗号“,”隔开，就可以连成一串输出： 1print('The quick brown fox', 'jumps over', 'the lazy dog') #逗号在显示中为空格 print()会依次打印每个字符串，遇到逗号“,”会输出一个空格 print()也可以打印整数，或者计算结果: 1print('100 + 200 =', 100 + 200) outputinput()，可以让用户输入字符串，并存放到一个变量里。比如输入用户的名字： 12name = input()print(name) input()可以让你显示一个字符串来提示用户输入 12name = input('please enter your name: ')print('hello,', name) 注释Python中单行注释以 # 开头 多行注释可以用多个 # 号，还有 ‘’’ 和 “””,可以在三引号之间自由地使用单引号与双引号 行与缩进python最具特色的就是使用缩进来表示代码块，不需要使用大括号 {} 。 缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。 多行语句Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠()来实现多行语句，例如： 123total = item_one + \\ item_two + \\ item_three 在 [], {}, 或 () 中的多行语句，不需要使用反斜杠()，例如： 12total = ['item_one', 'item_two', 'item_three', 'item_four', 'item_five'] 数字(Number)类型python中数字有四种类型：整数、布尔型、浮点数和复数。 int (整数),只有一种整数类型 int，没有单独的 long 类型。 int 类型可以指任何大小的整数 bool (布尔), True、False。 float (浮点数), 如 1.23、3E-2 complex (复数), 如 1 + 2j、 1.1 + 2.2j 字符串(String) python中单引号和双引号使用完全相同。 12word = '字符串'sentence = \"这是一个句子。\" 使用三引号(‘’’或”””)可以指定一个多行字符串。例: 12paragraph = \"\"\"这是一个段落，可以由多行组成\"\"\" 转义符 ‘\\‘ 反斜杠可以用来转义，使用r可以让反斜杠不发生转义。。 如 r”this is a line with \\n” 则\\n会显示，并不是换行。(r = raw 原，生) 按字面意义级联字符串，如”this” “is” “string”会被自动转换为thisisstring。两个字符串之间没有空格 字符串可以用 + 运算符连接在一起，用 * 运算符重复。 Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。 Python中的字符串不能改变。 Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。 字符串的截取的语法格式如下：变量[头下标:尾下标:步长] 空行函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。 空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。 记住：空行也是程序代码的一部分。 同一行显示多条语句Python可以在同一行中使用多条语句，语句之间使用分号(;)分割 多个语句构成代码组缩进相同的一组语句构成一个代码块，我们称之代码组。 像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。 我们将首行及后面的代码组称为一个子句(clause)。 123456if expression : suiteelif expressiom : suiteelse : suite import 与 from…import 在 python 用 import 或者 from…import 来导入相应的模块。 将整个模块(somemodule)导入，格式为： import somemodule 从某个模块中导入某个函数,格式为： from somemodule import somefunction 从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc 将某个模块中的全部函数导入，格式为： from somemodule import *","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Python学习笔记（一）","slug":"Python学习笔记-基本数据类型","date":"2020-03-05T08:43:14.000Z","updated":"2020-04-16T09:47:26.690Z","comments":true,"path":"2020/03/05/Python学习笔记-基本数据类型/","link":"","permalink":"http://yoursite.com/2020/03/05/Python学习笔记-基本数据类型/","excerpt":"","text":"变量的定义与赋值 Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建 等号（=）用来给变量赋值。可以同时给多个变量赋相同的值，也可以同时赋给不同类型的值 12345678910111213141516171819202122#单个变量赋值a = 1b = 2.5c = 'xiaoming'print('a=', a)print('b=', b)print('c=', c)'''结果为a= 1b= 2.5c= xiaoming'''#多个变量赋值a, b , c = 1, 2.1, 'robot'print(a,b,c) #print()可以同时输出几个变量，并且以空格隔开print(a)print(b)print(c)#结果：1 2.1 robot 标准数据类型Number（数字）:int, float, bool, complex（复数） String（字符串） List（列表） Tuple（元组） Set（集合） Dictionary（字典） 不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）； 可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。 ​ 可变数据与不可变数据的理解：https://blog.csdn.net/dan15188387481/article/details/49864613 Number 在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。 内置的 type() 函数可以用来查询变量所指的对象类型,还可以用 isinstance 来判断： isinstance 和 type 的区别在于： type()不会认为子类是一种父类类型。 isinstance()会认为子类是一种父类类型。 注意： 1、Python可以同时为多个变量赋值，如a, b = 1, 2。 2、一个变量可以通过赋值指向不同类型的对象。 3、数值的除法包含两个运算符：/ 返回一个浮点数，// 返回一个整数。 4、在混合计算时，Python会把整型转换成为浮点数。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Markdown 语法","slug":"markdown learning","date":"2020-02-10T08:10:14.000Z","updated":"2020-04-16T09:34:24.520Z","comments":true,"path":"2020/02/10/markdown learning/","link":"","permalink":"http://yoursite.com/2020/02/10/markdown learning/","excerpt":"","text":"Markdown 语法1. 标题的书写标题二级标题三级标题四级标题五级标题2. 正文书写正文直接输入就可以了 换行注意：需要在代码中实际空一行，直接换行的话，输出的是没有换行的 3. 代码块123代码块的书写在代码开头和结尾处写 123```pythonprint(&quot;hello word&quot;) 4. 正文中的代码正文中的代码通过输入``框出 例如 print(&quot;hello word&quot;) 5. 列表 1 有序列表 输入一个数字，然后加一个句号.(英文)，然后空格，按回车后会自动生成下一个 多级标题：输入一个数字，然后加一个句号.(英文)，然后空格，再按tab，一次缩进一级 1 第一级 1 第二级 1 第三级 加 tab 的话 无序列表 输入 - 然后空格 加 tab 可以显示为代码块格式 多级无序列表 再来一级 再来一级 加粗 **文字**倾斜 *文字*加粗加倾斜 ***文字***","categories":[],"tags":[{"name":"makedown","slug":"makedown","permalink":"http://yoursite.com/tags/makedown/"}]},{"title":"Git学习笔记（四）","slug":"Git学习笔记（四）","date":"2019-06-08T08:09:26.000Z","updated":"2020-04-16T09:43:22.568Z","comments":true,"path":"2019/06/08/Git学习笔记（四）/","link":"","permalink":"http://yoursite.com/2019/06/08/Git学习笔记（四）/","excerpt":"","text":"添加远程库，从本地库推送到远程库 在Github上新建一个仓库，复制仓库地址 一整套流程如下： 1234567891011mkdir [文件夹名]cd [文件夹名]git initvim [文件名]git add [文件名]git commit -m &quot;description&quot; [文件名]git remote -v //查看是否关联了远程库git remote add origin [远程库链接]git remote -v git push -u origin master //由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 Notice: 必须先将文件提交到本地库，才能推送，本地库为空会报错 ​ 错误提示：error: src refspec master does not match any 2 删除关联：git remote rm origin 克隆操作操作： 1git clone [远程地址] 效果： 把远程库下载到本地 创建origin远程库别名，即进行了与远程库的连接（连接到的是邀请加入的库的地址） 初始化本地库，即生成了.git文件 邀请成员参与这里参与的是一个项目，也就是一个远程库 必须先邀请，邀请到的成员才能将修改的文件push到本地库 远程库的修改与拉取在创建远程库的目录下操作 pull=fetch+merge 1234git fetch origin master [远程库地址别名] [远程分支名]//将远程库文件下载下来，并没有改变该目录下文件git merge origin/mastergit pull oringin master 解决冲突要点 如果不是基于 GitHub 远程库的最新版所做的修改， 不能推送， 必须先拉取。 拉取下来后如果进入冲突状态， 则按照“分支冲突解决” 操作解决即可。 跨团队合作修改人员做的工作： Fork 拉取到本地，修改 推送到远端 new pull request create pull request 发起人做的工作： 对话 审核代码 file changed 合并代码 merge pull request comfirm merge 将远程库拉取到本地","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Git学习笔记（三）","slug":"Git学习笔记（三）","date":"2019-06-08T02:09:26.000Z","updated":"2020-04-16T09:42:19.598Z","comments":true,"path":"2019/06/08/Git学习笔记（三）/","link":"","permalink":"http://yoursite.com/2019/06/08/Git学习笔记（三）/","excerpt":"","text":"查看历史记录git log 显示最完整 多屏显示控制： ​ 空格向下翻页 ​ b 向上翻页 ​ q 退出 git log –pretty =oneline git log –oneline 将哈希值缩短 git reflog 添加了移动到当前版本需要的步数 前进后退 基于索引值（推荐）： 1git reset --hard [局部索引值] 不必关心是前进还是后退，只要知道是到了哪个版本 使用^符号：只能往后退，不能往前 1git reset --hard HEAD^ （有几个^，说明后退几步） 使用~符号：只能后退 1git reset --had HEAD~n 后退n步 tail -n 3 [文件名] :查看文件的最后三行 reset命令的三个参数的区别 –soft:仅在本地库移动HEAD 本地库向后移 –mixed:在本地库移动HEAD；重置暂存区 本地库和暂存区都向后移动 –hard:在本地库移动HEAD；重置暂存区；重置工作区 找回删除的文件 工作区文件删除+恢复 123rm [flile name] //删除工作区文件git checkout -- [filename] //恢复工作区文件 工作区和存储区文件删除+恢复 1234rm [flile name] git add [flile name] //删除存储区的文件git reset --hard HEAD //恢复到上一个版本 永久删除文件+恢复 12345rm [flile name] //删除git add [flile name]git commit -m &quot;description&quot; [flile name] //删除本地库文件git reset --hard [历史记录哈希值] 操作：git reset –hard [指针位置] ​ 删除操作已经提交到了本地库：指针位置指向历史记录 ​ 删除操作尚未提交到本地库：指针位置使用HEAD 撤销修改 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 文件比较 git diff [文件名]：将工作区文件与暂存区进行比较 git diff [本地库中历史版本]【文件名】：工作区中和本地历史库版本比较 不带文件名会比较多个文件 123git diff good.txtgit diff HEAD(HEAD^) good.txtgit diff 分支hot-fix(服务器不停)/cool-fix（服务器停止下修复） 分支操作1234567891011121314151617181920212223242526272829创建分支：git branch[分支名]查看分支名：git branch -v切换分支: git checkout[分支名]创建+切换分支：git checkout -b &lt;name&gt;git branch -d &lt;branchName&gt;:删除一个名字为branchName的分支。如果该分支有提交未进行合并，则会删除失败。删除分支时必须切换到master，不然会报错git branch -D &lt;branchName&gt;:强制删除一个名字为branchName 的分支。如果该分支有提交未进行合并，也会删除成功。看到分支合并图:git log --graphgit log --graph --pretty=oneline --abbrev-commit` //只会显示图，哈希值，提交信息合并分支：第一步：切换到接收修改的（被合并，增加新内容）上git checkout[被合并分支名]第二步：执行merge命令git merge[有新内容的分支名]解决冲突：第一步： 编辑文件， 删除特殊符号第二步： 把文件修改到满意的程度， 保存退出第三步： git add [文件名]第四步： git commit -m &quot;日志信息&quot;（此时 commit 一定不能带具体文件名） Q: git 切换分支时会把未add或未commit的内容带过去(在重新创建一个分支之后，如果不做提交操作的话，直接切换到主分支之后也是可以看到其他分支做的修改操作) A: (https://blog.csdn.net/stpeace/article/details/84351160) 因为未add的内容不属于任何一个分支， 未commit的内容也不属于任何一个分支。 也就是说，对于所有分支而言， 工作区和暂存区是公共的。 要想在分支间切换， 又不想又上述影响， 怎么办呢？ git stash搞起。要注意，在当前分支git stash的内容， 在其他分支也可以git stash pop出来，为什么？ 因为：工作区和暂存区是公共的。 解决方法： 分支管理策略 fast forward模式：也就是一般使用的 git merge [分支名]，这种模式合并完以后看不到分支的痕迹，只能看到master 强制禁用Fast forward模式： Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息 语法：git merge --no-ff -m &quot;merge with no-ff&quot; dev ​ //合并要创建一个新的commit，所以加上-m参数，把commit描述写进去 在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 查看分支图：git log --graph --pretty=oneline --abbrev-commit //只会显示图，哈希值，提交信息 bug分支Q:假如现在的Bug你还没有解决，而上边又给你派了一个新的Bug，而这个Bug相比较现在正在苦思冥想的Bug比较容易解决。你想先解决新的Bug，可是之前的Bug还没有解决完而不能提交。怎么办? 解决方法： Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作： 1git stash 解决完bug以后，切换回这个分支 查看保存的工作现场：git stash list 恢复工作现场： ​ 方法1：git stash pop //恢复的同时把stash内容也删了 ​ 方法2： ​ git stash apply [stash标号] //恢复现场 ​ git stash drop//删除stash内容 Feature 分支这个分支和普通分支没啥区别，是一种管理分支的策略 添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。 开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除。","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Git学习笔记（二）","slug":"Git学习笔记（二）","date":"2019-06-07T11:37:14.000Z","updated":"2019-06-08T12:15:29.927Z","comments":true,"path":"2019/06/07/Git学习笔记（二）/","link":"","permalink":"http://yoursite.com/2019/06/07/Git学习笔记（二）/","excerpt":"","text":"配置签名","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Git学习笔记（一）","slug":"Git学习笔记（一）","date":"2019-06-07T04:09:26.000Z","updated":"2019-06-08T12:15:20.560Z","comments":true,"path":"2019/06/07/Git学习笔记（一）/","link":"","permalink":"http://yoursite.com/2019/06/07/Git学习笔记（一）/","excerpt":"","text":"Linux命令： cd 目录/ ：进入一个目录 ll : 显示目录下的文件 ls -lA: 显示目录下的隐藏文件 ll|less: 分屏显示 q:退出 git本地库初始化进入想要创建的文件下操作 1234567891011$mkdir learngit：新建一个文件夹learngit$cd learngit/:进入learngit文件下操作$git init :初始化了一个git仓库.git文件（这个文件是隐藏的，需要用ls -lA 查看；git 目录中存放的是本地库相关的子目录和文件， 不要删除， 也不要胡乱修改 ）$pwd :显示.git文件完整路径","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]}]}