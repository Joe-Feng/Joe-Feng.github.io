<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content><meta name="keywords" content><meta name="author" content="Joe_Feng"><meta name="copyright" content="Joe_Feng"><title>It's better to burn out than to fade away | Joe's blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g3trl5f8k4j304b04bmx4.jpg"></div><div class="author-info__name text-center">Joe_Feng</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">10</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">2</span></a></div></div></div><nav id="nav" style="background-image: url(http://pic1.win4000.com/wallpaper/8/565d5415d62dd.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Joe's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">个人主页</a><a class="site-page" href="/archives">文章总览</a><a class="site-page" href="/categories/项目实战">项目实战</a><a class="site-page" href="/categories/读书/">读书笔记</a><a class="site-page" href="/categories/生活杂谈">生活杂谈</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Joe's blog</div><div id="site-sub-title">It's better to burn out than to fade away</div><div id="site-social-icons"><a class="social-icon" href="https://github.com/Joe-Feng" target="_blank"><i class="fa-github fa"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/20/TinyHttp/">TinyHttp源码剖析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/项目实战/">项目实战</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/TinyHttp/">TinyHttp</a></span><div class="content"><h3 id="TinyHttp源码剖析"><a href="#TinyHttp源码剖析" class="headerlink" title="TinyHttp源码剖析"></a>TinyHttp源码剖析</h3><h4 id="一、-TinyHttp源码剖析预备知识——HTTP协议"><a href="#一、-TinyHttp源码剖析预备知识——HTTP协议" class="headerlink" title="一、 TinyHttp源码剖析预备知识——HTTP协议"></a>一、 TinyHttp源码剖析预备知识——HTTP协议</h4><h4 id="1-HTTP协议概念"><a href="#1-HTTP协议概念" class="headerlink" title="1. HTTP协议概念"></a>1. HTTP协议概念</h4><p>HTTP协议，即超文本传输协议(Hypertext transfer protocol)。是一种详细规定了浏览器和万维网(WWW = World Wide Web)服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。</p>
<p>HTTP协议是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。</p>
<p>HTTP是一个<strong>应用层协议</strong>，由请求和响应构成，是一个<strong>标准的客户端服务器模型</strong>。HTTP是一个<strong>无状态的协议。</strong></p>
<p>在Internet中所有的传输都是通过TCP/IP进行的。HTTP协议作为TCP/IP模型中应用层的协议也不例外。HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。</p>
<p><strong>HTTP默认的端口号为80，HTTPS的端口号为443。</strong></p>
<p><strong>浏览网页是HTTP的主要应用，但是这并不代表HTTP就只能应用于网页的浏览。</strong>HTTP是一种协议，只要通信的双方都遵守这个协议，HTTP就能有用武之地。比如咱们常用的QQ，迅雷这些软件，都会使用HTTP协议(还包括其他的协议)。</p>
<h4 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h4><ol>
<li><p><strong>HTTP 0.9和1.0使用非持续连接</strong>：限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。<strong>HTTP 1.1使用持续连接</strong>：不必为每个web对象创建一个新的连接，一个连接可以传送多个对象，采用这种方式可以节省传输时间。</p>
</li>
<li><p><strong>无状态</strong>：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。</p></li></ol></div><a class="more" href="/2020/03/20/TinyHttp/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/15/进程、线程的同步与通信/">进程的互斥、同步、通信</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-15</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/操作系统/">操作系统</a></span><div class="content"><h2 id="进程的互斥、同步、通信"><a href="#进程的互斥、同步、通信" class="headerlink" title="进程的互斥、同步、通信"></a>进程的互斥、同步、通信</h2><p>进程的互斥、同步、通信都是基于竞争和协作关系而存在的。</p>
<p>为了解决进程间<strong>竞争关系</strong>（<strong>间接制约关系</strong>）而引入<strong>进程互斥</strong>；</p>
<p>为了解决进程间<strong>松散的协作</strong>关系( <strong>直接制约关系</strong>)而引入<strong>进程同步</strong>；</p>
<p>为了解决进程间<strong>紧密的协作</strong>关系而引入<strong>进程通信</strong>。</p>
<hr>
<h3 id="进程的互斥"><a href="#进程的互斥" class="headerlink" title="进程的互斥"></a>进程的互斥</h3><p>资源竞争出现了两个控制问题：</p>
<p>一个是<strong>死锁 （deadlock ）问题</strong>，一组进程如果都获得了部分资源，还想要得到其他进程所占有的资源，最终所有的进程将陷入死锁。</p>
<p>另一个是<strong>饥饿（starvation ）问题</strong>，这是指这样一种情况：一个进程由于其他进程总是优先于它而被无限期拖延。</p>
<p>进程的互斥（mutual exclusion ）是解决进程间竞争关系( <strong>间接制约关系</strong>) 的手段。 </p>
<p><strong>进程互斥</strong>指若干个进程要使用同一共享资源时，任何时刻最多允许一个进程去使用，其他要使用该资源的进程必须等待，直到占有资源的进程释放该资源。</p>
<hr>
<h3 id="进程的同步"><a href="#进程的同步" class="headerlink" title="进程的同步"></a>进程的同步</h3><p>进程的同步（Synchronization）是解决进程间协作关系( <strong>直接制约关系</strong>) 的手段。</p>
<p><strong>进程间的同步是双方不知道对方名字的间接协作</strong>，例如，通过共享访问一个缓冲区进行<strong>松散式协作</strong>；</p>
<p><strong>进程同步</strong>指两个以上进程基于某个条件来协调它们的活动。一个进程的执行依赖于另一个协作进程的消息或信号，当一个进程没有得到来自于另一个进程的消息或信号时则需等待，直到消息或信号到达才被唤醒。</p>
<p><strong>进程互斥关系是一种特殊的进程同步关系</strong>，即逐次使用互斥共享资源，也是对进程使用资源次序上的一种协调。</p>
<h4 id="进程的同步方法：（进程互斥关系是一种特殊的进程同步关系，所以也可用于进程的互斥）"><a href="#进程的同步方法：（进程互斥关系是一种特殊的进程同步关系，所以也可用于进程的互斥）" class="headerlink" title="进程的同步方法：（进程互斥关系是一种特殊的进程同步关系，所以也可用于进程的互斥）"></a>进程的同步方法：（进程互斥关系是一种特殊的进程同步关系，所以也可用于进程的互斥）</h4><ol>
<li>信号量</li>
<li>互斥量</li>
<li>管程</li>
</ol>
<hr>
<h3 id="进程的通信"><a href="#进程的通信" class="headerlink" title="进程的通信"></a>进程的通信</h3><p>并发进程之间的交互必须满足两个基本要求：同步和通信。</p>
<p>进程竞争资源时要实施互斥，<strong>互斥是一种特殊的同步</strong>，实质上需要解决好进程同步问题，<strong>进程同步是一种进程通信</strong>，通过修改信号量，进程之间可建立起联系，相互协调运行和协同工作。但是信号量与PV操作只能传递信号，没有传递数据的能力。有些情况下进程之间交换的信息量虽很少，例如，仅仅交换某个状态信息，但很多情况下进程之间需要交换大批数据，例如，传送一批信息或整个文件，这可以通过一种新的通信机制来完成，<strong>进程之间互相交换信息的工作称之为进程通信IPC （InterProcess Communication）（主要是指大量数据的交换）。</strong></p>
<h4 id="进程的通信方式"><a href="#进程的通信方式" class="headerlink" title="进程的通信方式"></a>进程的通信方式</h4><p>进程间通信主要包括<strong>管道、系统IPC（包括消息队列、信号量、信号、共享内存等）</strong>、以及<strong>套接字socket。</strong></p>
<ol>
<li>管道：</li>
</ol>
<p>管道主要包括无名管道和命名管道:管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信</p>
<p>1.1.普通管道PIPE：</p>
<p>1)它是<strong>半双工</strong>的（即数据只能在一个方向上流动），具有固定的读端和写端</p>
<p>2)它<strong>只能用于具有亲缘关系的进程之间的通信</strong>（也是父子进程或者兄弟进程之间）</p>
<p>3)它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</p>
<p>1.2 命名管道FIFO：</p>
<p>1)FIFO可以在无关的进程之间交换数据</p>
<p>2)FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</p>
<ol start="2">
<li>系统IPC：</li>
</ol>
<p>2.1 <strong>消息队列</strong></p>
<p>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。 (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</p>
<p>特点：</p>
<p>1)消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</p>
<p>2)消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</p>
<p>3)消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</p>
<p>2.2 信号量semaphore</p>
<p>信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。<strong>信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据</strong>。</p>
<p>特点：</p>
<p>1)<strong>信号量用于进程间同步，若要在进程间传递数据需要结合共享内存</strong>。</p>
<p>2)信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。</p>
<p>3)每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</p>
<p>4)支持信号量组。</p>
<p>2.3 信号signal</p>
<p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
<p>signal，又简称为信号（软中断信号）用来<strong>通知进程发生了异步事件</strong>。
原理：<br>     一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。<strong>信号是进程间通信机制中唯一的异步通信机制</strong>，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。<strong>进程之间可以互相通过系统调用kill发送软中断信号。</strong>内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。信号机制除了基本通知功能外，还可以传递附加信息。</p>
<p>2.4 共享内存（Shared Memory）</p>
<p>它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等</p>
<p>特点：</p>
<p>1)共享内存是最快的一种IPC，因为进程是直接对内存进行存取</p>
<p>2)因为多个进程可以同时操作，所以需要进行同步</p>
<p>3)信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问</p>
<ol start="3">
<li>套接字SOCKET：</li>
</ol>
<p>socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。</p>
<hr>
<h3 id="线程的通信方式（查阅了很多资料，把同步方式和通信方式混为一谈，那这里也把这两种当做一回事吧）"><a href="#线程的通信方式（查阅了很多资料，把同步方式和通信方式混为一谈，那这里也把这两种当做一回事吧）" class="headerlink" title="线程的通信方式（查阅了很多资料，把同步方式和通信方式混为一谈，那这里也把这两种当做一回事吧）"></a>线程的通信方式（查阅了很多资料，把同步方式和通信方式混为一谈，那这里也把这两种当做一回事吧）</h3><ol>
<li>临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；</li>
<li>互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</li>
<li>信号量Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。</li>
<li>事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</li>
</ol>
<p><strong>信号量与互斥量的区别：</strong></p>
<p><strong>信号量：多线程同步使用的；</strong>一个线程完成某个动作后通过信号告诉别的线程，别的线程才可以执行某些动作；<br>  <strong>互斥量：多线程互斥使用的；</strong>一个线程占用某个资源，那么别的线程就无法访问，直到该线程离开，其他线程才可以访问该资源</p>
<p>互斥锁的作用就是互斥，mutual exclusive，是用来保护临界区(critical section)的。所谓临界区就是代码的一个区间，如果两个线程同时执行就有可能出问题，所以需要互斥锁来保护。</p>
<p>信号量（semaphore）是一种更高级的同步机制，<strong>mutex可以说是semaphore在仅取值0/1时的特例。</strong>Semaphore可以有更多的取值空间，用来实现更加复杂的同步，而不单单是线程间互斥。</p>
<pre><code>1、互斥量用于线程的互斥，信号量用于线程的同步：
   互斥：指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排他性。但是互斥无法限制访问者对资源的访问顺序，所以访问是无序的；
   同步：指在互斥的基础上（多数情况），通过其他机制实现访问者对资源的有序访问。大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况指可以允许多个访问者同时访问资源。

2、互斥量值只能是0/1，信号量值可以为非负整数：
    一个互斥量只能用于一个资源的互斥访问不能实现多个资源的多线程互斥问题；
    一个信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量时，也可以完成一个资源的互斥访问；

3、互斥量的加锁和解锁必须由同一线程分别对应使用；而信号量可以由一个线程释放，另外一个线程得到。</code></pre></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/10/死锁 活锁 饥饿/">死锁 活锁 饥饿</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-10</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/操作系统/">操作系统</a></span><div class="content"><h2 id="死锁-活锁-饥饿"><a href="#死锁-活锁-饥饿" class="headerlink" title="死锁 活锁 饥饿"></a>死锁 活锁 饥饿</h2><h3 id="死锁（争来争去-谁也得不到）"><a href="#死锁（争来争去-谁也得不到）" class="headerlink" title="死锁（争来争去 谁也得不到）"></a>死锁（争来争去 谁也得不到）</h3><p>死锁：是指<strong>两个或两个以上的进程（或线程）</strong>在执行过程中，因<strong>争夺资源而造成的一种互相等待的现象</strong>，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p>
<p><strong>死锁发生的条件</strong></p>
<ul>
<li><p>互斥条件：线程对资源的访问是排他性的，如果一个线程对占用了某资源，那么<strong>其他线程必须处于等待状态</strong>，直到资源被释放。</p>
</li>
<li><p>请求和保持条件：线程T1<strong>至少已经保持了一个资源R1占用</strong>,但<strong>又提出对另一个资源R2请求</strong>，而此时，资源R2被其他线程T2占用，于是该线程T1也必须等待，但<strong>又对自己保持的资源R1不释放</strong>。</p>
</li>
<li><p>不剥夺条件：线程已获得的资源，<strong>在未使用完之前，不能被其他线程剥夺，只能在使用完以后由自己释放</strong>。</p>
</li>
<li><p>环路等待条件：在死锁发生时，<strong>必然存在一个“进程-资源环形链”</strong>，即：{p0,p1,p2,…pn},进程p0（或线程）等待p1占用的资源，p1等待p2占用的资源，pn等待p0占用的资源。（最直观的理解是，p0等待p1占用的资源，而p1而在等待p0占用的资源，于是两个进程就相互等待）</p>
</li>
</ul>
<hr>
<h3 id="活锁（让来让去-谁都不拥有）"><a href="#活锁（让来让去-谁都不拥有）" class="headerlink" title="活锁（让来让去 谁都不拥有）"></a>活锁（让来让去 谁都不拥有）</h3><p>活锁：是指线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源。</p>
<hr>
<p><strong>关于“死锁与活锁”的比喻：</strong></p>
<p><strong>死锁：</strong>迎面开来的汽车A和汽车B过马路，汽车A得到了半条路的资源（满足死锁发生条件1：资源访问是排他性的，我占了路你就不能上来，除非你爬我头上去），汽车B占了汽车A的另外半条路的资源，A想过去必须请求另一半被B占用的道路（死锁发生条件2：必须整条车身的空间才能开过去，我已经占了一半，尼玛另一半的路被B占用了），B若想过去也必须等待A让路，A是辆兰博基尼，B是开奇瑞QQ的屌丝，A素质比较低开窗对B狂骂：快给老子让开，B很生气，你妈逼的，老子就不让（死锁发生条件3：在未使用完资源前，不能被其他线程剥夺），于是两者相互僵持一个都走不了（死锁发生条件4：环路等待条件），而且导致整条道上的后续车辆也走不了。</p>
<p><strong>活锁：</strong>马路中间有条小桥，只能容纳一辆车经过，桥两头开来两辆车A和B，A比较礼貌，示意B先过，B也比较礼貌，示意A先过，结果两人一直谦让谁也过不去。</p>
<hr>
<h3 id="饥饿（排多久-都轮不到自己）"><a href="#饥饿（排多久-都轮不到自己）" class="headerlink" title="饥饿（排多久 都轮不到自己）"></a>饥饿（排多久 都轮不到自己）</h3><p><strong>饥饿：</strong>是指如果线程T1占用了资源R，线程T2又请求封锁R，于是T2等待。T3也请求资源R，当T1释放了R上的封锁后，系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后，系统又批准了T4的请求……，T2可能永远等待。</p>
<p><strong>关于”饥饿“的比喻：</strong></p>
<p>在“首堵”北京的某一天，天气阴沉，空气中充斥着雾霾和地沟油的味道，某个苦逼的临时工交警正在处理塞车，有两条道A和B上都堵满了车辆，其中A道堵的时间最长，B相对相对堵的时间较短，这时，前面道路已疏通，交警按照最佳分配原则，示意B道上车辆先过，B道路上过了一辆又一辆，A道上排队时间最长的确没法通过，只能等B道上没有车辆通过的时候再等交警发指令让A道依次通过，这也就是ReentrantLock显示锁里提供的不公平锁机制（当然了，ReentrantLock也提供了公平锁的机制，由用户根据具体的使用场景而决定到底使用哪种锁策略），不公平锁能够提高吞吐量但不可避免的会造成某些线程的饥饿。</p>
<p>参考：<a href="https://www.cnblogs.com/ktgu/p/3529143.html" target="_blank" rel="noopener">https://www.cnblogs.com/ktgu/p/3529143.html</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/06/Python学习笔记-基本知识/">Python学习笔记（二）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-06</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/python/">python</a></span><div class="content"><h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><h2 id="print"><a href="#print" class="headerlink" title="print()"></a>print()</h2><p>*<em>你需要确保每一行的第一个字符前面都没有任何空格或制表格 *</em></p>
<p><strong>print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 **<code>end=&quot;&quot;</code></strong>：**</p>
<p><code>print()</code>函数可以接受多个字符串，用逗号“,”隔开，就可以连成一串输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'The quick brown fox'</span>, <span class="string">'jumps over'</span>, <span class="string">'the lazy dog'</span>)  <span class="comment">#逗号在显示中为空格</span></span><br></pre></td></tr></table></figure>

<p><code>print()</code>会依次打印每个字符串，<strong>遇到逗号“,”会输出一个空格</strong></p>
<p><code>print()</code>也可以打印整数，或者计算结果:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'100 + 200 ='</span>, <span class="number">100</span> + <span class="number">200</span>)</span><br></pre></td></tr></table></figure>

<h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><p><code>input()</code>，可以让用户输入字符串，并存放到一个变量里。比如输入用户的名字：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = input()</span><br><span class="line">print(name)</span><br></pre></td></tr></table></figure>

<p><code>input()</code>可以让你显示一个字符串来提示用户输入</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = input(<span class="string">'please enter your name: '</span>)</span><br><span class="line">print(<span class="string">'hello,'</span>, name)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Python中单行注释以 <strong>#</strong> 开头</p>
<p>多行注释可以用多个 <strong>#</strong> 号，还有 <strong>‘’’</strong> 和 <strong>“””</strong>,可以在三引号之间自由地使用单引号与双引号 </p>
<hr>
<h2 id="行与缩进"><a href="#行与缩进" class="headerlink" title="行与缩进"></a>行与缩进</h2><p>python最具特色的就是使用缩进来表示代码块，不需要使用大括号 <strong>{}</strong> 。</p>
<p>缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。</p>
<hr>
<h2 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h2><p>Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠()来实现多行语句，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br></pre></td></tr></table></figure>

<p>在 [], {}, 或 () 中的多行语句，不需要使用反斜杠()，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">total = [<span class="string">'item_one'</span>, <span class="string">'item_two'</span>, <span class="string">'item_three'</span>,</span><br><span class="line">        <span class="string">'item_four'</span>, <span class="string">'item_five'</span>]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="数字-Number-类型"><a href="#数字-Number-类型" class="headerlink" title="数字(Number)类型"></a>数字(Number)类型</h2><p>python中数字有四种类型：整数、布尔型、浮点数和复数。</p>
<ul>
<li><strong>int</strong> (整数),只有一种整数类型 int，没有单独的 long 类型。 int 类型可以指任何大小的整数 </li>
<li><strong>bool</strong> (布尔), True、False。</li>
<li><strong>float</strong> (浮点数), 如 1.23、3E-2</li>
<li><strong>complex</strong> (复数), 如 1 + 2j、 1.1 + 2.2j</li>
</ul>
<hr>
<h2 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串(String)"></a>字符串(String)</h2><ul>
<li><p>python中单引号和双引号使用完全相同。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">word = <span class="string">'字符串'</span></span><br><span class="line">sentence = <span class="string">"这是一个句子。"</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>使用三引号(‘’’或”””)可以指定一个多行字符串。例:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">paragraph = <span class="string">"""这是一个段落，</span></span><br><span class="line"><span class="string">可以由多行组成"""</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>转义符 ‘\‘</p>
</li>
<li><p>反斜杠可以用来转义，使用r可以让反斜杠不发生转义。。 如 r”this is a line with \n” 则\n会显示，并不是换行。(r = raw 原，生)</p>
</li>
<li><p>按字面意义级联字符串，如”this” “is” “string”会被自动转换为thisisstring。两个字符串之间没有空格</p>
</li>
<li><p>字符串可以用 + 运算符连接在一起，用 * 运算符重复。</p>
</li>
<li><p>Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。</p>
</li>
<li><p>Python中的字符串不能改变。</p>
</li>
<li><p>Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。</p>
</li>
<li><p>字符串的截取的语法格式如下：<strong>变量[头下标:尾下标:步长]</strong></p>
</li>
</ul>
<hr>
<h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</p>
<p>空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。</p>
<p><strong>记住：</strong>空行也是程序代码的一部分。</p>
<hr>
<h2 id="同一行显示多条语句"><a href="#同一行显示多条语句" class="headerlink" title="同一行显示多条语句"></a>同一行显示多条语句</h2><p>Python可以在同一行中使用多条语句，语句之间使用分号(;)分割</p>
<hr>
<h2 id="多个语句构成代码组"><a href="#多个语句构成代码组" class="headerlink" title="多个语句构成代码组"></a>多个语句构成代码组</h2><p>缩进相同的一组语句构成一个代码块，我们称之代码组。</p>
<p>像if、while、def和class这样的复合语句，<strong>首行以关键字开始，以冒号( : )结束，</strong>该行之后的一行或多行代码构成代码组。</p>
<p>我们将首行及后面的代码组称为一个子句(clause)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> expression :</span><br><span class="line">	suite</span><br><span class="line"><span class="keyword">elif</span> expressiom :</span><br><span class="line">	suite</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">	suite</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="import-与-from…import"><a href="#import-与-from…import" class="headerlink" title="import 与 from…import"></a>import 与 from…import</h2><ul>
<li>在 python 用 <strong>import</strong> 或者 <strong>from…import</strong> 来导入相应的模块。</li>
<li>将整个模块(somemodule)导入，格式为： <strong>import somemodule</strong></li>
<li>从某个模块中导入某个函数,格式为： <strong>from somemodule import somefunction</strong></li>
<li>从某个模块中导入多个函数,格式为： <strong>from somemodule import firstfunc, secondfunc, thirdfunc</strong></li>
<li>将某个模块中的全部函数导入，格式为： <strong>from somemodule import *</strong></li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/05/Python学习笔记-基本数据类型/">Python学习笔记（一）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-05</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/python/">python</a></span><div class="content"><h1 id="变量的定义与赋值"><a href="#变量的定义与赋值" class="headerlink" title="变量的定义与赋值"></a>变量的定义与赋值</h1><ol>
<li><p>Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建</p>
</li>
<li><p>等号（=）用来给变量赋值。可以同时给多个变量赋相同的值，也可以同时赋给不同类型的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#单个变量赋值</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2.5</span></span><br><span class="line">c = <span class="string">'xiaoming'</span></span><br><span class="line">print(<span class="string">'a='</span>, a)</span><br><span class="line">print(<span class="string">'b='</span>, b)</span><br><span class="line">print(<span class="string">'c='</span>, c)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">结果为a= 1</span></span><br><span class="line"><span class="string">b= 2.5</span></span><br><span class="line"><span class="string">c= xiaoming</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#多个变量赋值</span></span><br><span class="line">a, b , c = <span class="number">1</span>, <span class="number">2.1</span>, <span class="string">'robot'</span></span><br><span class="line">print(a,b,c)   <span class="comment">#print()可以同时输出几个变量，并且以空格隔开</span></span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果：1 2.1 robot</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h1><p>Number（数字）:int, float, bool, complex（复数）</p>
<p>String（字符串）</p>
<p>List（列表）</p>
<p>Tuple（元组）</p>
<p>Set（集合）</p>
<p>Dictionary（字典）</p>
</li>
</ol>
<ul>
<li><p><strong>不可变数据（3 个）：</strong>Number（数字）、String（字符串）、Tuple（元组）；</p>
</li>
<li><p><strong>可变数据（3 个）：</strong>List（列表）、Dictionary（字典）、Set（集合）。</p>
<p>​    可变数据与不可变数据的理解：<a href="https://blog.csdn.net/dan15188387481/article/details/49864613" target="_blank" rel="noopener">https://blog.csdn.net/dan15188387481/article/details/49864613</a></p>
<h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2></li>
</ul>
<p>在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</p>
<p>内置的 type() 函数可以用来查询变量所指的对象类型,还可以用 isinstance 来判断：</p>
<p>isinstance 和 type 的区别在于：</p>
<ul>
<li>type()不会认为子类是一种父类类型。</li>
<li>isinstance()会认为子类是一种父类类型。</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>1、Python可以同时为多个变量赋值，如a, b = 1, 2。</li>
<li>2、一个变量可以通过赋值指向不同类型的对象。</li>
<li>3、数值的除法包含两个运算符：<strong>/</strong> 返回一个浮点数，<strong>//</strong> 返回一个整数。</li>
<li>4、在混合计算时，Python会把整型转换成为浮点数。</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/10/markdown learning/">Markdown 语法</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-10</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/makedown/">makedown</a></span><div class="content"><h1 id="Markdown-语法"><a href="#Markdown-语法" class="headerlink" title="Markdown 语法"></a>Markdown 语法</h1><h2 id="1-标题的书写"><a href="#1-标题的书写" class="headerlink" title="1. 标题的书写"></a>1. 标题的书写</h2><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h2 id="2-正文书写"><a href="#2-正文书写" class="headerlink" title="2. 正文书写"></a>2. 正文书写</h2><p>正文直接输入就可以了</p>
<p>换行注意：需要在代码中实际空一行，<br>直接换行的话，输出的是没有换行的</p>
<h2 id="3-代码块"><a href="#3-代码块" class="headerlink" title="3. 代码块"></a>3. 代码块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">代码块的书写</span><br><span class="line"></span><br><span class="line">在代码开头和结尾处写</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```python</span><br><span class="line">print(&quot;hello word&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="4-正文中的代码"><a href="#4-正文中的代码" class="headerlink" title="4. 正文中的代码"></a>4. 正文中的代码</h2><p>正文中的代码通过输入``框出</p>
<p>例如 <code>print(&quot;hello word&quot;)</code></p>
<h2 id="5-列表"><a href="#5-列表" class="headerlink" title="5. 列表"></a>5. 列表</h2><ol>
<li><p>1 有序列表 </p>
<p> 输入一个数字，然后加一个句号.(英文)，然后空格，按回车后会自动生成下一个</p>
<p> 多级标题：输入一个数字，然后加一个句号.(英文)，然后空格，再按tab，一次缩进一级</p>
</li>
<li><p>1 第一级</p>
<ol>
<li><p>1 第二级</p>
<ol>
<li><p>1 第三级</p>
<p>加 tab 的话</p>
</li>
</ol>
</li>
</ol>
<ul>
<li><p>无序列表</p>
<p>   输入 - 然后空格</p>
<p>   加 tab 可以显示为代码块格式</p>
</li>
</ul>
</li>
</ol>
<ul>
<li>多级无序列表<ul>
<li>再来一级<ul>
<li>再来一级</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>加粗</strong></p>
<pre><code>**文字**</code></pre><p><em>倾斜</em></p>
<pre><code>*文字*</code></pre><p><strong><em>加粗加倾斜</em></strong></p>
<pre><code>***文字***</code></pre></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/08/Git学习笔记（四）/">Git学习笔记（四）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Git/">Git</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/git/">git</a></span><div class="content"><h3 id="添加远程库，从本地库推送到远程库"><a href="#添加远程库，从本地库推送到远程库" class="headerlink" title="添加远程库，从本地库推送到远程库"></a>添加远程库，从本地库推送到远程库</h3><ol>
<li>在Github上新建一个仓库，复制仓库地址</li>
<li>一整套流程如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mkdir [文件夹名]</span><br><span class="line">cd [文件夹名]</span><br><span class="line">git init</span><br><span class="line">vim [文件名]</span><br><span class="line">git add [文件名]</span><br><span class="line">git commit -m &quot;description&quot; [文件名]</span><br><span class="line">git remote -v //查看是否关联了远程库</span><br><span class="line">git remote add origin [远程库链接]</span><br><span class="line">git remote -v </span><br><span class="line">git push -u  origin master   </span><br><span class="line">//由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</span><br></pre></td></tr></table></figure>

<p>Notice: </p>
<ol>
<li>必须先将文件提交到本地库，才能推送，本地库为空会报错</li>
</ol>
<p>​        错误提示：error: src refspec master does not match any</p>
<p>   2  删除关联：git remote rm origin</p>
<h3 id="克隆操作"><a href="#克隆操作" class="headerlink" title="克隆操作"></a>克隆操作</h3><p>操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone [远程地址]</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ol>
<li><p>把远程库下载到本地</p>
</li>
<li><p>创建origin远程库别名，即进行了与远程库的连接（连接到的是邀请加入的库的地址）</p>
</li>
<li><p>初始化本地库，即生成了.git文件</p>
<h3 id="邀请成员参与"><a href="#邀请成员参与" class="headerlink" title="邀请成员参与"></a>邀请成员参与</h3><p>这里参与的是一个项目，也就是一个远程库</p>
<p>必须先邀请，邀请到的成员才能将修改的文件push到本地库</p>
<h3 id="远程库的修改与拉取"><a href="#远程库的修改与拉取" class="headerlink" title="远程库的修改与拉取"></a>远程库的修改与拉取</h3><p>在创建远程库的目录下操作</p>
<p>pull=fetch+merge</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master  [远程库地址别名] [远程分支名]//将远程库文件下载下来，并没有改变该目录下文件</span><br><span class="line">git merge origin/master</span><br><span class="line"></span><br><span class="line">git pull oringin master</span><br></pre></td></tr></table></figure>

<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><p> 如果不是基于 GitHub 远程库的<strong>最新版</strong>所做的修改， 不能推送， 必须先拉<br>取。<br> 拉取下来后如果进入冲突状态， 则按照“分支冲突解决” 操作解决即可。 </p>
<h3 id="跨团队合作"><a href="#跨团队合作" class="headerlink" title="跨团队合作"></a>跨团队合作</h3><p><strong>修改人员做的工作：</strong></p>
<p>Fork</p>
<p>拉取到本地，修改</p>
<p>推送到远端</p>
<p>new pull request</p>
<p>create pull request</p>
<p><strong>发起人做的工作：</strong></p>
<p>对话</p>
<p>审核代码  file changed</p>
<p>合并代码  merge pull request   comfirm merge</p>
<p>将远程库拉取到本地</p>
</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/08/Git学习笔记（三）/">Git学习笔记（三）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Git/">Git</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/git/">git</a></span><div class="content"><h3 id="查看历史记录"><a href="#查看历史记录" class="headerlink" title="查看历史记录"></a>查看历史记录</h3><p>git log 显示最完整</p>
<p>多屏显示控制：</p>
<p>​    空格向下翻页</p>
<p>​    b 向上翻页</p>
<p>​    q 退出</p>
<p>git log –pretty =oneline </p>
<p>git log –oneline  将哈希值缩短</p>
<p>git reflog  添加了移动到当前版本需要的步数</p>
<h3 id="前进后退"><a href="#前进后退" class="headerlink" title="前进后退"></a>前进后退</h3><ul>
<li><p>基于索引值（推荐）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard [局部索引值]</span><br></pre></td></tr></table></figure>

<p>不必关心是前进还是后退，只要知道是到了哪个版本</p>
</li>
<li><p>使用^符号：只能往后退，不能往前</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^ （有几个^，说明后退几步）</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用~符号：只能后退</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --had HEAD~n     后退n步</span><br></pre></td></tr></table></figure>
</li>
<li><p>tail -n 3 [文件名] :查看文件的最后三行</p>
<h4 id="reset命令的三个参数的区别"><a href="#reset命令的三个参数的区别" class="headerlink" title="reset命令的三个参数的区别"></a>reset命令的三个参数的区别</h4><blockquote>
<p>–soft:仅在本地库移动HEAD       本地库向后移</p>
<p>–mixed:在本地库移动HEAD；重置暂存区   本地库和暂存区都向后移动</p>
<p>–hard:在本地库移动HEAD；重置暂存区；重置工作区</p>
</blockquote>
</li>
</ul>
<h3 id="找回删除的文件"><a href="#找回删除的文件" class="headerlink" title="找回删除的文件"></a>找回删除的文件</h3><ul>
<li><h4 id="工作区文件删除-恢复"><a href="#工作区文件删除-恢复" class="headerlink" title="工作区文件删除+恢复"></a>工作区文件删除+恢复</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm [flile name] //删除工作区文件</span><br><span class="line"></span><br><span class="line">git checkout -- [filename] //恢复工作区文件</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="工作区和存储区文件删除-恢复"><a href="#工作区和存储区文件删除-恢复" class="headerlink" title="工作区和存储区文件删除+恢复"></a>工作区和存储区文件删除+恢复</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rm [flile name] </span><br><span class="line">git add [flile name] //删除存储区的文件</span><br><span class="line"></span><br><span class="line">git reset --hard HEAD //恢复到上一个版本</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="永久删除文件-恢复"><a href="#永久删除文件-恢复" class="headerlink" title="永久删除文件+恢复"></a>永久删除文件+恢复</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rm [flile name] //删除</span><br><span class="line">git add [flile name]</span><br><span class="line">git commit -m &quot;description&quot; [flile name] //删除本地库文件</span><br><span class="line"></span><br><span class="line">git reset --hard [历史记录哈希值]</span><br></pre></td></tr></table></figure>

<p><strong>操作</strong>：git reset –hard [指针位置]</p>
<p>​            删除操作已经提交到了本地库：指针位置指向历史记录</p>
<p>​            删除操作尚未提交到本地库：指针位置使用HEAD</p>
<h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><ul>
<li><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p>
</li>
<li><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p>
</li>
<li><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192" target="_blank" rel="noopener">版本回退</a>一节，不过前提是没有推送到远程库。</p>
</li>
<li><h3 id="文件比较"><a href="#文件比较" class="headerlink" title="文件比较"></a>文件比较</h3></li>
</ul>
<p>git diff [文件名]：将工作区文件与暂存区进行比较</p>
<p>git diff [本地库中历史版本]【文件名】：工作区中和本地历史库版本比较</p>
<p>不带文件名会比较多个文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git diff good.txt</span><br><span class="line">git diff HEAD(HEAD^) good.txt</span><br><span class="line">git diff</span><br></pre></td></tr></table></figure>

<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>hot-fix(服务器不停)/cool-fix（服务器停止下修复）</p>
<h4 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">创建分支：git branch[分支名]</span><br><span class="line"></span><br><span class="line">查看分支名：git branch -v</span><br><span class="line"></span><br><span class="line">切换分支: git checkout[分支名]</span><br><span class="line"></span><br><span class="line">创建+切换分支：git checkout -b &lt;name&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git branch -d &lt;branchName&gt;:删除一个名字为branchName的分支。如果该分支有提交未进行合并，则会删除失败。</span><br><span class="line">删除分支时必须切换到master，不然会报错</span><br><span class="line"></span><br><span class="line">git branch -D &lt;branchName&gt;:强制删除一个名字为branchName 的分支。如果该分支有提交未进行合并，也会删除成功。</span><br><span class="line"></span><br><span class="line">看到分支合并图:git log --graph</span><br><span class="line"></span><br><span class="line">git log --graph --pretty=oneline --abbrev-commit`  //只会显示图，哈希值，提交信息</span><br><span class="line"></span><br><span class="line">合并分支：</span><br><span class="line">第一步：切换到接收修改的（被合并，增加新内容）上</span><br><span class="line">git checkout[被合并分支名]</span><br><span class="line">第二步：执行merge命令</span><br><span class="line">git merge[有新内容的分支名]</span><br><span class="line"></span><br><span class="line">解决冲突：</span><br><span class="line">第一步： 编辑文件， 删除特殊符号</span><br><span class="line">第二步： 把文件修改到满意的程度， 保存退出</span><br><span class="line">第三步： git add [文件名]</span><br><span class="line">第四步： git commit -m &quot;日志信息&quot;（此时 commit 一定不能带具体文件名）</span><br></pre></td></tr></table></figure>

<p><strong>Q:</strong></p>
<p><strong>git 切换分支时会把未add或未commit的内容带过去</strong>(在重新创建一个分支之后，如果不做提交操作的话，直接切换到主分支之后也是可以看到其他分支做的修改操作)</p>
<p><strong>A:</strong>   (<a href="https://blog.csdn.net/stpeace/article/details/84351160" target="_blank" rel="noopener">https://blog.csdn.net/stpeace/article/details/84351160</a>)</p>
<p>因为未add的内容不属于任何一个分支， 未commit的内容也不属于任何一个分支。 也就是说，<strong>对于所有分支而言， 工作区和暂存区是公共的。</strong></p>
<p>要想在分支间切换， 又不想又上述影响， 怎么办呢？ git stash搞起。要注意，在当前分支git stash的内容， 在其他分支也可以git stash pop出来，为什么？ 因为：工作区和暂存区是公共的。</p>
<p><strong>解决方法</strong>：<a href="https://blog.csdn.net/AsheAndWine/article/details/79003270" target="_blank" rel="noopener"></a></p>
<h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><ul>
<li><p><strong>fast forward模式</strong>：也就是一般使用的  <code>git merge [分支名]</code>，这种模式合并完以后看不到分支的痕迹，只能看到master</p>
</li>
<li><p><strong>强制禁用<code>Fast forward</code>模式</strong>：</p>
<p>Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息</p>
<p>语法：<code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code> </p>
<p>​            //合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去</p>
</li>
<li><p>在实际开发中，我们应该按照几个<strong>基本原则进行分支管理</strong>：</p>
<p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
<p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p>
<p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p>
</li>
<li><p><strong>查看分支图：</strong><code>git log --graph --pretty=oneline --abbrev-commit</code>  //只会显示图，哈希值，提交信息</p>
</li>
</ul>
<h3 id="bug分支"><a href="#bug分支" class="headerlink" title="bug分支"></a>bug分支</h3><p>Q:<strong>假如现在的Bug你还没有解决，而上边又给你派了一个新的Bug，而这个Bug相比较现在正在苦思冥想的Bug比较容易解决。你想先解决新的Bug，可是之前的Bug还没有解决完而不能提交。怎么办?</strong></p>
<p><strong>解决方法：</strong></p>
<p>Git还提供了一个<code>stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>

<p>解决完bug以后，切换回这个分支</p>
<p>查看保存的工作现场：<code>git stash list</code></p>
<p>恢复工作现场：</p>
<p>​                            方法1：<code>git stash pop</code>     //恢复的同时把stash内容也删了</p>
<p>​                            方法2：</p>
<p>​                           <code>git stash apply [stash标号]</code>  //恢复现场</p>
<p>​                           <code>git  stash drop</code>//删除stash内容</p>
<h3 id="Feature-分支"><a href="#Feature-分支" class="headerlink" title="Feature 分支"></a>Feature 分支</h3><p>这个分支和普通分支没啥区别，是一种管理分支的策略</p>
<p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p>
<ul>
<li><p>开发一个新feature，最好新建一个分支；</p>
</li>
<li><p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/07/Git学习笔记（二）/">Git学习笔记（二）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Git/">Git</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/git/">git</a></span><div class="content"><h3 id="配置签名"><a href="#配置签名" class="headerlink" title="配置签名"></a>配置签名</h3></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/07/Git学习笔记（一）/">Git学习笔记（一）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Git/">Git</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/git/">git</a></span><div class="content"><h2 id="Linux命令："><a href="#Linux命令：" class="headerlink" title="Linux命令："></a>Linux命令：</h2><ul>
<li>cd 目录/ ：进入一个目录</li>
<li>ll : 显示目录下的文件</li>
<li>ls -lA: 显示目录下的隐藏文件</li>
<li>ll|less: 分屏显示</li>
<li>q:退出</li>
</ul>
<h2 id="git本地库初始化"><a href="#git本地库初始化" class="headerlink" title="git本地库初始化"></a>git本地库初始化</h2><p>进入想要创建的文件下操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$mkdir learngit：新建一个文件夹learngit</span><br><span class="line"></span><br><span class="line">$cd learngit/:进入learngit文件下操作</span><br><span class="line"></span><br><span class="line">$git init :初始化了一个git仓库.git文件</span><br><span class="line"></span><br><span class="line">（这个文件是隐藏的，需要用ls -lA 查看；</span><br><span class="line"></span><br><span class="line">git 目录中存放的是本地库相关的子目录和文件， 不要删除， 也不要胡乱修改 ）</span><br><span class="line"></span><br><span class="line">$pwd :显示.git文件完整路径</span><br></pre></td></tr></table></figure>

</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span></div></nav></div></div><footer class="footer-bg" style="background-image: url(http://pic1.win4000.com/wallpaper/8/565d5415d62dd.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By Joe_Feng</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>